/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkjs_webpack_c3_client_node"] = self["webpackChunkjs_webpack_c3_client_node"] || []).push([["node_modules_c3_ui_UiSdlCategoricalLineBarChartReact_tsx_uiComponentLibraryReact"],{

/***/ "./node_modules/@c3/ui/UiSdlCategoricalLineBarChartReact.tsx_uiComponentLibraryReact":
/*!*******************************************************************!*\
  !*** ./node_modules/@c3/ui/UiSdlCategoricalLineBarChartReact.tsx ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __GetDependency__: () => (/* binding */ _get__),\n/* harmony export */   __ResetDependency__: () => (/* binding */ _reset__),\n/* harmony export */   __RewireAPI__: () => (/* binding */ _RewireAPI__),\n/* harmony export */   __Rewire__: () => (/* binding */ _set__),\n/* harmony export */   __get__: () => (/* binding */ _get__),\n/* harmony export */   __set__: () => (/* binding */ _set__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getAxisFields: () => (/* binding */ getAxisFields),\n/* harmony export */   getGradients: () => (/* binding */ getGradients),\n/* harmony export */   getMarkLines: () => (/* binding */ getMarkLines),\n/* harmony export */   getNewSeries: () => (/* binding */ getNewSeries),\n/* harmony export */   updateProps: () => (/* binding */ updateProps)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react_uiComponentLibraryReact\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _c3_sdl_react_hooks_useTranslate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @c3/sdl-react/hooks/useTranslate */ \"./node_modules/@c3/sdl-react/hooks/useTranslate.js_uiComponentLibraryReact\");\n/* harmony import */ var _c3_sdl_react_reactComponents_SDLLineBarChart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @c3/sdl-react/reactComponents/SDLLineBarChart */ \"./node_modules/@c3/sdl-react/reactComponents/SDLLineBarChart.jsx_uiComponentLibraryReact\");\n/* harmony import */ var _c3_ui_UiSdlTransformEvalMetricsResultToUiSdlChartData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @c3/ui/UiSdlTransformEvalMetricsResultToUiSdlChartData */ \"webpack/container/remote/@c3/ui/UiSdlTransformEvalMetricsResultToUiSdlChartData_uiComponentLibraryReact\");\n/* harmony import */ var _c3_ui_UiSdlTransformEvalMetricsResultToUiSdlChartData__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_c3_ui_UiSdlTransformEvalMetricsResultToUiSdlChartData__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var gradstop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gradstop */ \"./node_modules/gradstop/index.js_uiComponentLibraryReact\");\n/* harmony import */ var gradstop__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gradstop__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _c3_sdl_react_helpers_EchartsOptionHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @c3/sdl-react/helpers/EchartsOptionHelper */ \"./node_modules/@c3/sdl-react/helpers/EchartsOptionHelper.js_uiComponentLibraryReact\");\n/* harmony import */ var _c3_css_library_components_chart_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @c3/css-library/components/_chart.scss */ \"./node_modules/@c3/css-library/components/_chart.scss_uiComponentLibraryReact\");\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\n/*\n * Copyright 2009-2024 C3 AI (www.c3.ai). All Rights Reserved.\n * This material, including without limitation any software, is the confidential trade secret and proprietary\n * information of C3 and its licensors. Reproduction, use and/or distribution of this material in any form is\n * strictly prohibited except as set forth in a written license agreement with C3 and/or its authorized distributors.\n * This material may be covered by one or more patents or pending patent applications.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Method to get markLines from markLinesDataSpec in case markLinesDataSpec and markLinesData is provided,\n * we need to match the markLinesConfig to the markLinesData.\n * @param markLinesDataSpec\n * @param markLinesData\n * @returns array of markLinesConfig coming from markLinesDataSpec and markLines.\n */\nconst getMarkLines = (markLinesDataSpec, markLinesData) => {\n  const combinedMarkLines = [];\n  if (markLinesDataSpec !== null && markLinesDataSpec !== void 0 && markLinesDataSpec.markLinesConfig) {\n    var _markLinesDataSpec$ma;\n    (_markLinesDataSpec$ma = markLinesDataSpec.markLinesConfig) === null || _markLinesDataSpec$ma === void 0 || _markLinesDataSpec$ma.forEach(markLineConfig => {\n      var _markLinesData$objs;\n      const {\n        entityId,\n        fieldName,\n        markLineDataPoint\n      } = markLineConfig;\n      markLineDataPoint && combinedMarkLines.push({\n        ...markLineConfig,\n        markLineDataPoint\n      });\n      markLinesData === null || markLinesData === void 0 || (_markLinesData$objs = markLinesData.objs) === null || _markLinesData$objs === void 0 || _markLinesData$objs.forEach(markData => {\n        if (fieldName && entityId && (markData === null || markData === void 0 ? void 0 : markData.id) === entityId) {\n          combinedMarkLines.push({\n            ...markLineConfig,\n            markLineDataPoint: markData[fieldName]\n          });\n        }\n      });\n    });\n  }\n  return combinedMarkLines;\n};\nconst getAxisFields = dataSpec => {\n  var _dataSpec$xAxisField;\n  const xAxisFieldName = dataSpec === null || dataSpec === void 0 || (_dataSpec$xAxisField = dataSpec.xAxisField) === null || _dataSpec$xAxisField === void 0 || (_dataSpec$xAxisField = _dataSpec$xAxisField.fieldName) === null || _dataSpec$xAxisField === void 0 ? void 0 : _dataSpec$xAxisField.trim();\n  const yAxisFieldNames = dataSpec === null || dataSpec === void 0 ? void 0 : dataSpec.yAxisFields.map(f => {\n    var _f$fieldName;\n    return (_f$fieldName = f.fieldName) === null || _f$fieldName === void 0 ? void 0 : _f$fieldName.trim();\n  });\n  return {\n    xAxisFieldName,\n    yAxisFieldNames\n  };\n};\n\n// TODO: PLAT-56983 - Refactor this to use the same gradients as the other charts\nconst getGradients = () => {\n  return {\n    gradient1: ['#49BFA9', '#ED6921', '#DB1C3C'],\n    'gradient1-inv': ['#DB1C3C', '#ED6921', '#49BFA9'],\n    gradient2: ['#ED6921', '#8D4BE3'],\n    'gradient2-inv': ['#8D4BE3', '#ED6921'],\n    gradient3: ['#8A90AB', '#DB1C3C'],\n    'gradient3-inv': ['#DB1C3C', '#8A90AB']\n  };\n};\nconst getNewSeries = (series, yIndexOffset, yAxisFields, removeExtraSeries, newYAxisFields, removeLegend) => {\n  const gradients = _get__(\"getGradients\")();\n  return series.flatMap((s, ind) => {\n    var _yAxisFields$ind;\n    ind -= yIndexOffset;\n    if (ind < 0) {\n      return [s];\n    }\n\n    // Don't bother with fields outside of yAxisFields range -- fields added through orderString. Let markLine through to be filtered out later\n    if (!yAxisFields[ind] && s.id !== _get__(\"MARK_LINE_ID\") && removeExtraSeries) {\n      return {\n        ...s,\n        filterOut: true\n      };\n    }\n\n    // If a series has UiSdlGradientColorSetting, we break the series into multiple series.\n    if ((_yAxisFields$ind = yAxisFields[ind]) !== null && _yAxisFields$ind !== void 0 && _yAxisFields$ind.colorConfigurationStrategy) {\n      removeLegend = true;\n      const strategy = yAxisFields[ind].colorConfigurationStrategy;\n      const weightedGradient = !!strategy.weightedMethodConfig;\n      const gradientType = strategy.gradient || 'gradient1';\n\n      // Remove null data\n      const data = s.data.map(d => d[1]).filter(d => d != null && typeof d === 'number');\n      if (data.length === 0) {\n        newYAxisFields.push(yAxisFields[ind]);\n        return [s];\n      }\n\n      // Threshold for each color\n      const thresholds = [];\n      let numberOfColors;\n      if (weightedGradient) {\n        numberOfColors = strategy.numberOfColors || 100;\n        const minVal = strategy.weightedMethodConfig.minimum == null ? Math.min(...data) : strategy.weightedMethodConfig.minimum;\n        const maxVal = strategy.weightedMethodConfig.maximum == null ? Math.max(...data) : strategy.weightedMethodConfig.maximum;\n        const stepSize = (maxVal - minVal) / numberOfColors;\n        for (let i = 0; i < numberOfColors; i++) {\n          thresholds.push(minVal + i * stepSize);\n        }\n      } else {\n        const uniqueSortedData = [...new Set(data)].sort((a, b) => a - b);\n        numberOfColors = strategy.numberOfColors || uniqueSortedData.length;\n        const stepSize = Math.max(1, uniqueSortedData.length / numberOfColors);\n        for (let i = 0; i < uniqueSortedData.length; i += stepSize) {\n          thresholds.push(uniqueSortedData[Math.floor(i)]);\n        }\n      }\n      let colorGradient;\n      if (numberOfColors < 3) {\n        colorGradient = gradients[gradientType].slice(0, numberOfColors);\n      } else {\n        colorGradient = _get__(\"gradstop\")({\n          stops: numberOfColors,\n          inputFormat: 'hex',\n          colorArray: gradients[gradientType]\n        });\n      }\n      const sArray = [];\n\n      // Break one series into multiple\n      for (let i = 0; i < thresholds.length; i++) {\n        let hasValue = false;\n        const fieldSuffix = i > 0 ? i : '';\n        const newData = s.data.map(d => {\n          if (d[1] >= thresholds[i] && (i === thresholds.length - 1 || d[1] < thresholds[i + 1])) {\n            hasValue = true;\n            return [d[0], d[1]];\n          } else {\n            return [d[0], null];\n          }\n        });\n        if (hasValue) {\n          sArray.push({\n            ...s,\n            data: newData,\n            stack: 'total'\n          });\n          newYAxisFields.push({\n            ...yAxisFields[ind],\n            color: colorGradient[i],\n            fieldName: yAxisFields[ind].fieldName + fieldSuffix\n          });\n        }\n      }\n      return sArray;\n    } else {\n      if (yAxisFields[ind]) {\n        newYAxisFields.push(yAxisFields[ind]);\n      }\n      return [s];\n    }\n  }).map((s, ind) => {\n    return {\n      ...s,\n      id: (s === null || s === void 0 ? void 0 : s.id) === _get__(\"MARK_LINE_ID\") ? _get__(\"MARK_LINE_ID\") : ind.toString()\n    };\n  }).filter(s => !s.filterOut);\n};\nconst updateProps = (props, newSeries, newYAxisFields, removeLegend) => {\n  props = {\n    ...props,\n    data: {\n      ...props.data,\n      series: newSeries\n    },\n    dataSpec: {\n      ...props.dataSpec,\n      yAxisFields: newYAxisFields\n    }\n  };\n\n  // Legend isn't supported when we use gradient coloring\n  if (removeLegend) {\n    delete props.legend;\n  }\n  return props;\n};\nconst UiSdlCategoricalLineBarChart = props => {\n  var _props$data, _props$dataSpec, _fields, _fields2, _fields3;\n  const translate = _get__(\"useTranslate\")(props);\n  let removeLegend = false;\n  let series = (_props$data = props.data) === null || _props$data === void 0 ? void 0 : _props$data.series;\n  let fields = (_props$dataSpec = props.dataSpec) === null || _props$dataSpec === void 0 || (_props$dataSpec = _props$dataSpec.xAxisField) === null || _props$dataSpec === void 0 || (_props$dataSpec = _props$dataSpec.redirectLink) === null || _props$dataSpec === void 0 || (_props$dataSpec = _props$dataSpec.pageVariableFilterField) === null || _props$dataSpec === void 0 ? void 0 : _props$dataSpec.split(',');\n  fields = (_fields = fields) === null || _fields === void 0 ? void 0 : _fields.map(f => f.trim());\n  const {\n    xAxisFieldName,\n    yAxisFieldNames\n  } = _get__(\"getAxisFields\")(props.dataSpec);\n\n  // Filter out fields that are beeing used by the yAxisFields\n  fields = (_fields2 = fields) === null || _fields2 === void 0 ? void 0 : _fields2.filter(f => !yAxisFieldNames.includes(f));\n  let yIndexOffset = 0;\n\n  /**\n   * Sometimes the url will require fields not specified as fieldName in the data spec.\n   * If this is the case, the partially applied action will have resulted in more series\n   * than we need to correctly plot the chart. We use this block to assign url mappings\n   * and remove any unnecessary series before plotting a SDLChart.\n   */\n  if ((_fields3 = fields) !== null && _fields3 !== void 0 && _fields3.length) {\n    if (fields.includes(xAxisFieldName)) {\n      yIndexOffset = fields.length - 1;\n    } else {\n      yIndexOffset = fields.length;\n    }\n  }\n  if (series) {\n    const yAxisFields = props.dataSpec.yAxisFields;\n    const newYAxisFields = [];\n    let newSeries = _get__(\"getNewSeries\")(series, yIndexOffset, yAxisFields, props.removeExtraSeries, newYAxisFields, removeLegend);\n    props = {\n      ...props,\n      data: {\n        ...props.data,\n        series: newSeries\n      },\n      dataSpec: {\n        ...props.dataSpec,\n        yAxisFields: newYAxisFields\n      }\n    };\n\n    // Legend isn't supported when we use gradient coloring\n    if (removeLegend) {\n      delete props.legend;\n    }\n  }\n  const markLines = _get__(\"getMarkLines\")(props.markLinesDataSpec, props.markLinesData);\n  return /*#__PURE__*/_get__(\"React\").createElement(_get__(\"SDLLineBarChart\"), _extends({}, props, {\n    generateSeriesId: _get__(\"generateSeriesId\"),\n    translate: translate,\n    markLines: markLines\n  }));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_get__(\"UiSdlCategoricalLineBarChart\"));\n\nfunction _getGlobalObject() {\n  try {\n    if (!!__webpack_require__.g) {\n      return __webpack_require__.g;\n    }\n  } catch (e) {\n    try {\n      if (!!window) {\n        return window;\n      }\n    } catch (e) {\n      return this;\n    }\n  }\n}\n;\nvar _RewireModuleId__ = null;\nfunction _getRewireModuleId__() {\n  if (_RewireModuleId__ === null) {\n    let globalVariable = _getGlobalObject();\n    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {\n      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;\n    }\n    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;\n  }\n  return _RewireModuleId__;\n}\nfunction _getRewireRegistry__() {\n  let theGlobalVariable = _getGlobalObject();\n  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {\n    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);\n  }\n  return theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__;\n}\nfunction _getRewireExportsRegistry__() {\n  let theGlobalVariable = _getGlobalObject();\n  if (!theGlobalVariable.__$$GLOBAL_REWIRE_EXPORTS_REGISTRY__) {\n    theGlobalVariable.__$$GLOBAL_REWIRE_EXPORTS_REGISTRY__ = Object.create(null);\n  }\n  return theGlobalVariable.__$$GLOBAL_REWIRE_EXPORTS_REGISTRY__;\n}\nconst _sync_internal_state_with_exports__ = false;\nconst _exports_to_reset__ = new Map();\nfunction _record_export_to_reset__(variableName, value) {\n  if (!_sync_internal_state_with_exports__) {\n    return;\n  }\n  if (!Object.prototype.hasOwnProperty.call(exports, variableName)) {\n    return;\n  }\n  if (!_exports_to_reset__.has(variableName)) {\n    _exports_to_reset__.set(variableName, value);\n  }\n}\nfunction _restore_exports__() {\n  const entries = _exports_to_reset__.entries();\n  for (const [variableName, value] of entries) {\n    exports[variableName] = value;\n  }\n  _exports_to_reset__.clear();\n}\nfunction _maybe_update_export__(variableName, value) {\n  if (!_sync_internal_state_with_exports__) {\n    return;\n  }\n  if (!Object.prototype.hasOwnProperty.call(exports, variableName)) {\n    return;\n  }\n  _record_export_to_reset__(variableName, exports[variableName]);\n  exports[variableName] = value;\n}\nfunction _getRewiredData__() {\n  let moduleId = _getRewireModuleId__();\n  let registry = _getRewireRegistry__();\n  let rewireData = registry[moduleId];\n  if (!rewireData) {\n    registry[moduleId] = Object.create(null);\n    rewireData = registry[moduleId];\n  }\n  let exportsRegistry = _getRewireExportsRegistry__();\n  if (!exportsRegistry[moduleId]) {\n    exportsRegistry[moduleId] = _restore_exports__;\n  }\n  return rewireData;\n}\n(function registerResetAll() {\n  let theGlobalVariable = _getGlobalObject();\n  if (!theGlobalVariable['__rewire_reset_all__']) {\n    theGlobalVariable['__rewire_reset_all__'] = function () {\n      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);\n      const exportsRegistry = _getRewireExportsRegistry__();\n      for (const restoreFunc of Object.values(exportsRegistry)) {\n        restoreFunc();\n      }\n      theGlobalVariable.__$$GLOBAL_REWIRE_EXPORTS_REGISTRY__ = Object.create(null);\n    };\n  }\n})();\nvar INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';\nlet _RewireAPI__ = {};\n(function () {\n  function addPropertyToAPIObject(name, value) {\n    Object.defineProperty(_RewireAPI__, name, {\n      value: value,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  addPropertyToAPIObject('__get__', _get__);\n  addPropertyToAPIObject('__GetDependency__', _get__);\n  addPropertyToAPIObject('__Rewire__', _set__);\n  addPropertyToAPIObject('__set__', _set__);\n  addPropertyToAPIObject('__reset__', _reset__);\n  addPropertyToAPIObject('__ResetDependency__', _reset__);\n  addPropertyToAPIObject('__with__', _with__);\n})();\nfunction _get__(variableName) {\n  let rewireData = _getRewiredData__();\n  if (rewireData[variableName] === undefined) {\n    return _get_original__(variableName);\n  } else {\n    var value = rewireData[variableName];\n    if (value === INTENTIONAL_UNDEFINED) {\n      return undefined;\n    } else {\n      return value;\n    }\n  }\n}\nfunction _get_original__(variableName) {\n  switch (variableName) {\n    case \"getGradients\":\n      return getGradients;\n    case \"MARK_LINE_ID\":\n      return _c3_sdl_react_helpers_EchartsOptionHelper__WEBPACK_IMPORTED_MODULE_5__.MARK_LINE_ID;\n    case \"gradstop\":\n      return (gradstop__WEBPACK_IMPORTED_MODULE_4___default());\n    case \"useTranslate\":\n      return _c3_sdl_react_hooks_useTranslate__WEBPACK_IMPORTED_MODULE_1__.useTranslate;\n    case \"getAxisFields\":\n      return getAxisFields;\n    case \"getNewSeries\":\n      return getNewSeries;\n    case \"getMarkLines\":\n      return getMarkLines;\n    case \"generateSeriesId\":\n      return _c3_ui_UiSdlTransformEvalMetricsResultToUiSdlChartData__WEBPACK_IMPORTED_MODULE_3__.generateSeriesId;\n    case \"UiSdlCategoricalLineBarChart\":\n      return UiSdlCategoricalLineBarChart;\n    case \"React\":\n      return _filterWildcardImport__(react__WEBPACK_IMPORTED_MODULE_0__);\n    case \"SDLLineBarChart\":\n      return _c3_sdl_react_reactComponents_SDLLineBarChart__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n  }\n  return undefined;\n}\nfunction _assign__(variableName, value) {\n  let rewireData = _getRewiredData__();\n  if (rewireData[variableName] === undefined) {\n    return _set_original__(variableName, value);\n  } else {\n    _maybe_update_export__(variableName, value);\n    return rewireData[variableName] = value;\n  }\n}\nfunction _set_original__(variableName, _value) {\n  switch (variableName) {}\n  return undefined;\n}\nfunction _update_operation__(operation, variableName, prefix) {\n  var oldValue = _get__(variableName);\n  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;\n  _assign__(variableName, newValue);\n  return prefix ? newValue : oldValue;\n}\nfunction _set__(variableName, value) {\n  let rewireData = _getRewiredData__();\n  if (typeof variableName === 'object') {\n    Object.keys(variableName).forEach(function (name) {\n      rewireData[name] = variableName[name];\n    });\n    return function () {\n      Object.keys(variableName).forEach(function (name) {\n        _reset__(variableName);\n      });\n    };\n  } else {\n    _maybe_update_export__(variableName, value);\n    if (value === undefined) {\n      rewireData[variableName] = INTENTIONAL_UNDEFINED;\n    } else {\n      rewireData[variableName] = value;\n    }\n    return function () {\n      _reset__(variableName);\n    };\n  }\n}\nfunction _reset__(variableName) {\n  let rewireData = _getRewiredData__();\n  delete rewireData[variableName];\n  if (Object.keys(rewireData).length == 0) {\n    delete _getRewireRegistry__()[_getRewireModuleId__];\n  }\n  if (_exports_to_reset__.has(variableName)) {\n    exports[variableName] = _exports_to_reset__.get(variableName);\n    _exports_to_reset__.delete(variableName);\n  }\n}\nfunction _with__(object) {\n  let rewireData = _getRewiredData__();\n  var rewiredVariableNames = Object.keys(object);\n  var previousValues = {};\n  function reset() {\n    rewiredVariableNames.forEach(function (variableName) {\n      rewireData[variableName] = previousValues[variableName];\n    });\n  }\n  return function (callback) {\n    rewiredVariableNames.forEach(function (variableName) {\n      previousValues[variableName] = rewireData[variableName];\n      rewireData[variableName] = object[variableName];\n    });\n    let result = callback();\n    if (!!result && typeof result.then == 'function') {\n      result.then(reset).catch(reset);\n    } else {\n      reset();\n    }\n    return result;\n  };\n}\nlet _typeOfOriginalExport = typeof UiSdlCategoricalLineBarChart;\nfunction addNonEnumerableProperty(name, value) {\n  Object.defineProperty(UiSdlCategoricalLineBarChart, name, {\n    value: value,\n    enumerable: false,\n    configurable: true\n  });\n}\nif ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(UiSdlCategoricalLineBarChart)) {\n  addNonEnumerableProperty('__get__', _get__);\n  addNonEnumerableProperty('__GetDependency__', _get__);\n  addNonEnumerableProperty('__Rewire__', _set__);\n  addNonEnumerableProperty('__set__', _set__);\n  addNonEnumerableProperty('__reset__', _reset__);\n  addNonEnumerableProperty('__ResetDependency__', _reset__);\n  addNonEnumerableProperty('__with__', _with__);\n  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);\n}\nfunction _filterWildcardImport__(wildcardImport = {}) {\n  let validPropertyNames = Object.keys(wildcardImport).filter(function (propertyName) {\n    return propertyName !== '__get__' && propertyName !== '__set__' && propertyName !== '__reset__' && propertyName !== '__with__' && propertyName !== '__GetDependency__' && propertyName !== '__Rewire__' && propertyName !== '__ResetDependency__';\n  });\n  return validPropertyNames.reduce(function (filteredWildcardImport, propertyName) {\n    filteredWildcardImport[propertyName] = wildcardImport[propertyName];\n    return filteredWildcardImport;\n  }, {});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGMzL3VpL1VpU2RsQ2F0ZWdvcmljYWxMaW5lQmFyQ2hhcnRSZWFjdC50c3hfdWlDb21wb25lbnRMaWJyYXJ5UmVhY3QiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFFaUM7QUFDWTtBQUNjO0FBQzFEO0FBQ3lDO0FBRXpCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1NLFlBQVksR0FBR0EsQ0FBQ0MsaUJBQWlCLEVBQUVDLGFBQWEsS0FBSztFQUN6RCxNQUFNQyxpQkFBMEQsR0FBRyxFQUFFO0VBQ3JFLElBQUlGLGlCQUFpQixhQUFqQkEsaUJBQWlCLGVBQWpCQSxpQkFBaUIsQ0FBRUcsZUFBZSxFQUFFO0lBQUEsSUFBQUMscUJBQUE7SUFDdEMsQ0FBQUEscUJBQUEsR0FBQUosaUJBQWlCLENBQUNHLGVBQWUsY0FBQUMscUJBQUEsZUFBakNBLHFCQUFBLENBQW1DQyxPQUFPLENBQUVDLGNBQWMsSUFBSztNQUFBLElBQUFDLG1CQUFBO01BQzdELE1BQU07UUFBRUMsUUFBUTtRQUFFQyxTQUFTO1FBQUVDO01BQWtCLENBQUMsR0FBR0osY0FBYztNQUNqRUksaUJBQWlCLElBQUlSLGlCQUFpQixDQUFDUyxJQUFJLENBQUM7UUFBRSxHQUFHTCxjQUFjO1FBQUVJO01BQWtCLENBQUMsQ0FBQztNQUNyRlQsYUFBYSxhQUFiQSxhQUFhLGdCQUFBTSxtQkFBQSxHQUFiTixhQUFhLENBQUVXLElBQUksY0FBQUwsbUJBQUEsZUFBbkJBLG1CQUFBLENBQXFCRixPQUFPLENBQUVRLFFBQVEsSUFBSztRQUN6QyxJQUFJSixTQUFTLElBQUlELFFBQVEsSUFBSSxDQUFBSyxRQUFRLGFBQVJBLFFBQVEsdUJBQVJBLFFBQVEsQ0FBRUMsRUFBRSxNQUFLTixRQUFRLEVBQUU7VUFDdEROLGlCQUFpQixDQUFDUyxJQUFJ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LFVBRC9EdEYsNEJBQTRCO0FBQUEsU0FBQXVGLHlCQUFBOUIsSUFBQSxFQUFBdEIsS0FBQTtFQUFBVCxNQUFBLENBQUFnQyxjQUFBLENBQTVCMUQsNEJBQTRCLEVBQUF5RCxJQUFBO0lBQUF0QixLQUFBLEVBQUFBLEtBQUE7SUFBQXdCLFVBQUE7SUFBQUMsWUFBQTtFQUFBO0FBQUE7QUFBQSxLQUFBMEIscUJBQUEsaUJBQUFBLHFCQUFBLG9CQUFBNUQsTUFBQSxDQUFBOEQsWUFBQSxDQUE1QnhGLDRCQUE0QjtFQUFBdUYsd0JBQUEsWUFBQXhJLE1BQUE7RUFBQXdJLHdCQUFBLHNCQUFBeEksTUFBQTtFQUFBd0ksd0JBQUEsZUFBQTFCLE1BQUE7RUFBQTBCLHdCQUFBLFlBQUExQixNQUFBO0VBQUEwQix3QkFBQSxjQUFBekIsUUFBQTtFQUFBeUIsd0JBQUEsd0JBQUF6QixRQUFBO0VBQUF5Qix3QkFBQSxhQUFBeEIsT0FBQTtFQUFBd0Isd0JBQUEsa0JBQUFoQyxZQUFBO0FBQUE7QUFBQSxTQUFBVyx3QkFBQXVCLGNBQUE7RUFBQSxJQUFBQyxrQkFBQSxHQUFBaEUsTUFBQSxDQUFBaUQsSUFBQSxDQUFBYyxjQUFBLEVBQUE1SCxNQUFBLFdBQUE4SCxZQUFBO0lBQUEsT0FBQUEsWUFBQSxrQkFBQUEsWUFBQSxrQkFBQUEsWUFBQSxvQkFBQUEsWUFBQSxtQkFBQUEsWUFBQSw0QkFBQUEsWUFBQSxxQkFBQUEsWUFBQTtFQUFBO0VBQUEsT0FBQUQsa0JBQUEsQ0FBQUUsTUFBQSxXQUFBQyxzQkFBQSxFQUFBRixZQUFBO0lBQUFFLHNCQUFBLENBQUFGLFlBQUEsSUFBQUYsY0FBQSxDQUFBRSxZQUFBO0lBQUEsT0FBQUUsc0JBQUE7RUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWlDb21wb25lbnRMaWJyYXJ5UmVhY3QvLi9ub2RlX21vZHVsZXMvQGMzL3VpL1VpU2RsQ2F0ZWdvcmljYWxMaW5lQmFyQ2hhcnRSZWFjdC50c3g/ZTZlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAyNCBDMyBBSSAod3d3LmMzLmFpKS4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgbWF0ZXJpYWwsIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gYW55IHNvZnR3YXJlLCBpcyB0aGUgY29uZmlkZW50aWFsIHRyYWRlIHNlY3JldCBhbmQgcHJvcHJpZXRhcnlcbiAqIGluZm9ybWF0aW9uIG9mIEMzIGFuZCBpdHMgbGljZW5zb3JzLiBSZXByb2R1Y3Rpb24sIHVzZSBhbmQvb3IgZGlzdHJpYnV0aW9uIG9mIHRoaXMgbWF0ZXJpYWwgaW4gYW55IGZvcm0gaXNcbiAqIHN0cmljdGx5IHByb2hpYml0ZWQgZXhjZXB0IGFzIHNldCBmb3J0aCBpbiBhIHdyaXR0ZW4gbGljZW5zZSBhZ3JlZW1lbnQgd2l0aCBDMyBhbmQvb3IgaXRzIGF1dGhvcml6ZWQgZGlzdHJpYnV0b3JzLlxuICogVGhpcyBtYXRlcmlhbCBtYXkgYmUgY292ZXJlZCBieSBvbmUgb3IgbW9yZSBwYXRlbnRzIG9yIHBlbmRpbmcgcGF0ZW50IGFwcGxpY2F0aW9ucy5cbiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBVaVNkbENhdGVnb3JpY2FsTGluZUJhckNoYXJ0IGFzIFByb3BzLCBVaVNkbExpbmVCYXJDaGFydE1hcmtMaW5lc0NvbmZpZyB9IGZyb20gJ0BjMy90eXBlcyc7XG5pbXBvcnQgeyB1c2VUcmFuc2xhdGUgfSBmcm9tICdAYzMvc2RsLXJlYWN0L2hvb2tzL3VzZVRyYW5zbGF0ZSc7XG5pbXBvcnQgU0RMTGluZUJhckNoYXJ0IGZyb20gJ0BjMy9zZGwtcmVhY3QvcmVhY3RDb21wb25lbnRzL1NETExpbmVCYXJDaGFydCc7XG5pbXBvcnQgeyBnZW5lcmF0ZVNlcmllc0lkIH0gZnJvbSAnQGMzL3VpL1VpU2RsVHJhbnNmb3JtRXZhbE1ldHJpY3NSZXN1bHRUb1VpU2RsQ2hhcnREYXRhJztcbmltcG9ydCBncmFkc3RvcCBmcm9tICdncmFkc3RvcCc7XG5pbXBvcnQgeyBNQVJLX0xJTkVfSUQgfSBmcm9tICdAYzMvc2RsLXJlYWN0L2hlbHBlcnMvRWNoYXJ0c09wdGlvbkhlbHBlcic7XG5cbmltcG9ydCAnQGMzL2Nzcy1saWJyYXJ5L2NvbXBvbmVudHMvX2NoYXJ0LnNjc3MnO1xuXG4vKipcbiAqIE1ldGhvZCB0byBnZXQgbWFya0xpbmVzIGZyb20gbWFya0xpbmVzRGF0YVNwZWMgaW4gY2FzZSBtYXJrTGluZXNEYXRhU3BlYyBhbmQgbWFya0xpbmVzRGF0YSBpcyBwcm92aWRlZCxcbiAqIHdlIG5lZWQgdG8gbWF0Y2ggdGhlIG1hcmtMaW5lc0NvbmZpZyB0byB0aGUgbWFya0xpbmVzRGF0YS5cbiAqIEBwYXJhbSBtYXJrTGluZXNEYXRhU3BlY1xuICogQHBhcmFtIG1hcmtMaW5lc0RhdGFcbiAqIEByZXR1cm5zIGFycmF5IG9mIG1hcmtMaW5lc0NvbmZpZyBjb21pbmcgZnJvbSBtYXJrTGluZXNEYXRhU3BlYyBhbmQgbWFya0xpbmVzLlxuICovXG5jb25zdCBnZXRNYXJrTGluZXMgPSAobWFya0xpbmVzRGF0YVNwZWMsIG1hcmtMaW5lc0RhdGEpID0+IHtcbiAgY29uc3QgY29tYmluZWRNYXJrTGluZXM6IEFycmF5PFVpU2RsTGluZUJhckNoYXJ0TWFya0xpbmVzQ29uZmlnPiA9IFtdO1xuICBpZiAobWFya0xpbmVzRGF0YVNwZWM/Lm1hcmtMaW5lc0NvbmZpZykge1xuICAgIG1hcmtMaW5lc0RhdGFTcGVjLm1hcmtMaW5lc0NvbmZpZz8uZm9yRWFjaCgobWFya0xpbmVDb25maWcpID0+IHtcbiAgICAgIGNvbnN0IHsgZW50aXR5SWQsIGZpZWxkTmFtZSwgbWFya0xpbmVEYXRhUG9pbnQgfSA9IG1hcmtMaW5lQ29uZmlnO1xuICAgICAgbWFya0xpbmVEYXRhUG9pbnQgJiYgY29tYmluZWRNYXJrTGluZXMucHVzaCh7IC4uLm1hcmtMaW5lQ29uZmlnLCBtYXJrTGluZURhdGFQb2ludCB9KTtcbiAgICAgIG1hcmtMaW5lc0RhdGE/Lm9ianM/LmZvckVhY2goKG1hcmtEYXRhKSA9PiB7XG4gICAgICAgIGlmIChmaWVsZE5hbWUgJiYgZW50aXR5SWQgJiYgbWFya0RhdGE/LmlkID09PSBlbnRpdHlJZCkge1xuICAgICAgICAgIGNvbWJpbmVkTWFya0xpbmVzLnB1c2goeyAuLi5tYXJrTGluZUNvbmZpZywgbWFya0xpbmVEYXRhUG9pbnQ6IG1hcmtEYXRhW2ZpZWxkTmFtZV0gfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb21iaW5lZE1hcmtMaW5lcztcbn07XG5cbmNvbnN0IGdldEF4aXNGaWVsZHMgPSAoZGF0YVNwZWMpID0+IHtcbiAgY29uc3QgeEF4aXNGaWVsZE5hbWUgPSBkYXRhU3BlYz8ueEF4aXNGaWVsZD8uZmllbGROYW1lPy50cmltKCk7XG4gIGNvbnN0IHlBeGlzRmllbGROYW1lcyA9IGRhdGFTcGVjPy55QXhpc0ZpZWxkcy5tYXAoKGYpID0+IGYuZmllbGROYW1lPy50cmltKCkpO1xuXG4gIHJldHVybiB7IHhBeGlzRmllbGROYW1lLCB5QXhpc0ZpZWxkTmFtZXMgfTtcbn07XG5cbi8vIFRPRE86IFBMQVQtNTY5ODMgLSBSZWZhY3RvciB0aGlzIHRvIHVzZSB0aGUgc2FtZSBncmFkaWVudHMgYXMgdGhlIG90aGVyIGNoYXJ0c1xuY29uc3QgZ2V0R3JhZGllbnRzID0gKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGdyYWRpZW50MTogWycjNDlCRkE5JywgJyNFRDY5MjEnLCAnI0RCMUMzQyddLFxuICAgICdncmFkaWVudDEtaW52JzogWycjREIxQzNDJywgJyNFRDY5MjEnLCAnIzQ5QkZBOSddLFxuICAgIGdyYWRpZW50MjogWycjRUQ2OTIxJywgJyM4RDRCRTMnXSxcbiAgICAnZ3JhZGllbnQyLWludic6IFsnIzhENEJFMycsICcjRUQ2OTIxJ10sXG4gICAgZ3JhZGllbnQzOiBbJyM4QTkwQUInLCAnI0RCMUMzQyddLFxuICAgICdncmFkaWVudDMtaW52JzogWycjREIxQzNDJywgJyM4QTkwQUInXSxcbiAgfTtcbn1cblxuY29uc3QgZ2V0TmV3U2VyaWVzID0gKHNlcmllcywgeUluZGV4T2Zmc2V0LCB5QXhpc0ZpZWxkcywgcmVtb3ZlRXh0cmFTZXJpZXMsIG5ld1lBeGlzRmllbGRzLCByZW1vdmVMZWdlbmQpID0+IHtcbiAgY29uc3QgZ3JhZGllbnRzID0gZ2V0R3JhZGllbnRzKCk7XG4gIHJldHVybiBzZXJpZXNcbiAgLmZsYXRNYXAoKHMsIGluZCkgPT4ge1xuICAgIGluZCAtPSB5SW5kZXhPZmZzZXQ7XG5cbiAgICBpZiAoaW5kIDwgMCkge1xuICAgICAgcmV0dXJuIFtzXTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBib3RoZXIgd2l0aCBmaWVsZHMgb3V0c2lkZSBvZiB5QXhpc0ZpZWxkcyByYW5nZSAtLSBmaWVsZHMgYWRkZWQgdGhyb3VnaCBvcmRlclN0cmluZy4gTGV0IG1hcmtMaW5lIHRocm91Z2ggdG8gYmUgZmlsdGVyZWQgb3V0IGxhdGVyXG4gICAgaWYgKCF5QXhpc0ZpZWxkc1tpbmRdICYmIHMuaWQgIT09IE1BUktfTElORV9JRCAmJiByZW1vdmVFeHRyYVNlcmllcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucyxcbiAgICAgICAgZmlsdGVyT3V0OiB0cnVlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHNlcmllcyBoYXMgVWlTZGxHcmFkaWVudENvbG9yU2V0dGluZywgd2UgYnJlYWsgdGhlIHNlcmllcyBpbnRvIG11bHRpcGxlIHNlcmllcy5cbiAgICBpZiAoeUF4aXNGaWVsZHNbaW5kXT8uY29sb3JDb25maWd1cmF0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHJlbW92ZUxlZ2VuZCA9IHRydWU7XG4gICAgICBjb25zdCBzdHJhdGVneSA9IHlBeGlzRmllbGRzW2luZF0uY29sb3JDb25maWd1cmF0aW9uU3RyYXRlZ3k7XG4gICAgICBjb25zdCB3ZWlnaHRlZEdyYWRpZW50ID0gISFzdHJhdGVneS53ZWlnaHRlZE1ldGhvZENvbmZpZztcbiAgICAgIGNvbnN0IGdyYWRpZW50VHlwZSA9IHN0cmF0ZWd5LmdyYWRpZW50IHx8ICdncmFkaWVudDEnO1xuXG4gICAgICAvLyBSZW1vdmUgbnVsbCBkYXRhXG4gICAgICBjb25zdCBkYXRhID0gcy5kYXRhLm1hcCgoZCkgPT4gZFsxXSkuZmlsdGVyKChkKSA9PiBkICE9IG51bGwgJiYgdHlwZW9mIGQgPT09ICdudW1iZXInKTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5ld1lBeGlzRmllbGRzLnB1c2goeUF4aXNGaWVsZHNbaW5kXSk7XG4gICAgICAgIHJldHVybiBbc107XG4gICAgICB9XG5cbiAgICAgIC8vIFRocmVzaG9sZCBmb3IgZWFjaCBjb2xvclxuICAgICAgY29uc3QgdGhyZXNob2xkcyA9IFtdO1xuICAgICAgbGV0IG51bWJlck9mQ29sb3JzO1xuXG4gICAgICBpZiAod2VpZ2h0ZWRHcmFkaWVudCkge1xuICAgICAgICBudW1iZXJPZkNvbG9ycyA9IHN0cmF0ZWd5Lm51bWJlck9mQ29sb3JzIHx8IDEwMDtcblxuICAgICAgICBjb25zdCBtaW5WYWwgPVxuICAgICAgICAgIHN0cmF0ZWd5LndlaWdodGVkTWV0aG9kQ29uZmlnLm1pbmltdW0gPT0gbnVsbCA/IE1hdGgubWluKC4uLmRhdGEpIDogc3RyYXRlZ3kud2VpZ2h0ZWRNZXRob2RDb25maWcubWluaW11bTtcbiAgICAgICAgY29uc3QgbWF4VmFsID1cbiAgICAgICAgICBzdHJhdGVneS53ZWlnaHRlZE1ldGhvZENvbmZpZy5tYXhpbXVtID09IG51bGwgPyBNYXRoLm1heCguLi5kYXRhKSA6IHN0cmF0ZWd5LndlaWdodGVkTWV0aG9kQ29uZmlnLm1heGltdW07XG5cbiAgICAgICAgY29uc3Qgc3RlcFNpemUgPSAobWF4VmFsIC0gbWluVmFsKSAvIG51bWJlck9mQ29sb3JzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDb2xvcnM7IGkrKykge1xuICAgICAgICAgIHRocmVzaG9sZHMucHVzaChtaW5WYWwgKyBpICogc3RlcFNpemUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB1bmlxdWVTb3J0ZWREYXRhID0gWy4uLm5ldyBTZXQoZGF0YSldLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgbnVtYmVyT2ZDb2xvcnMgPSBzdHJhdGVneS5udW1iZXJPZkNvbG9ycyB8fCB1bmlxdWVTb3J0ZWREYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3RlcFNpemUgPSBNYXRoLm1heCgxLCB1bmlxdWVTb3J0ZWREYXRhLmxlbmd0aCAvIG51bWJlck9mQ29sb3JzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmlxdWVTb3J0ZWREYXRhLmxlbmd0aDsgaSArPSBzdGVwU2l6ZSkge1xuICAgICAgICAgIHRocmVzaG9sZHMucHVzaCh1bmlxdWVTb3J0ZWREYXRhW01hdGguZmxvb3IoaSldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGNvbG9yR3JhZGllbnQ7XG5cbiAgICAgIGlmIChudW1iZXJPZkNvbG9ycyA8IDMpIHtcbiAgICAgICAgY29sb3JHcmFkaWVudCA9IGdyYWRpZW50c1tncmFkaWVudFR5cGVdLnNsaWNlKDAsIG51bWJlck9mQ29sb3JzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbG9yR3JhZGllbnQgPSBncmFkc3RvcCh7XG4gICAgICAgICAgc3RvcHM6IG51bWJlck9mQ29sb3JzLFxuICAgICAgICAgIGlucHV0Rm9ybWF0OiAnaGV4JyxcbiAgICAgICAgICBjb2xvckFycmF5OiBncmFkaWVudHNbZ3JhZGllbnRUeXBlXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNBcnJheSA9IFtdO1xuXG4gICAgICAvLyBCcmVhayBvbmUgc2VyaWVzIGludG8gbXVsdGlwbGVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhyZXNob2xkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZmllbGRTdWZmaXggPSBpID4gMCA/IGkgOiAnJztcbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IHMuZGF0YS5tYXAoKGQpID0+IHtcbiAgICAgICAgICBpZiAoZFsxXSA+PSB0aHJlc2hvbGRzW2ldICYmIChpID09PSB0aHJlc2hvbGRzLmxlbmd0aCAtIDEgfHwgZFsxXSA8IHRocmVzaG9sZHNbaSArIDFdKSkge1xuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIFtkWzBdLCBkWzFdXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtkWzBdLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICBzQXJyYXkucHVzaCh7XG4gICAgICAgICAgICAuLi5zLFxuICAgICAgICAgICAgZGF0YTogbmV3RGF0YSxcbiAgICAgICAgICAgIHN0YWNrOiAndG90YWwnLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbmV3WUF4aXNGaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAuLi55QXhpc0ZpZWxkc1tpbmRdLFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yR3JhZGllbnRbaV0sXG4gICAgICAgICAgICBmaWVsZE5hbWU6IHlBeGlzRmllbGRzW2luZF0uZmllbGROYW1lICsgZmllbGRTdWZmaXgsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzQXJyYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh5QXhpc0ZpZWxkc1tpbmRdKSB7XG4gICAgICAgIG5ld1lBeGlzRmllbGRzLnB1c2goeUF4aXNGaWVsZHNbaW5kXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbc107XG4gICAgfVxuICB9KVxuICAubWFwKChzLCBpbmQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucyxcbiAgICAgIGlkOiBzPy5pZCA9PT0gTUFSS19MSU5FX0lEID8gTUFSS19MSU5FX0lEIDogaW5kLnRvU3RyaW5nKCksXG4gICAgfTtcbiAgfSlcbiAgLmZpbHRlcigocykgPT4gIXMuZmlsdGVyT3V0KTtcbn1cblxuY29uc3QgdXBkYXRlUHJvcHMgPSAocHJvcHMsIG5ld1NlcmllcywgbmV3WUF4aXNGaWVsZHMsIHJlbW92ZUxlZ2VuZCkgPT4ge1xuICBwcm9wcyA9IHtcbiAgICAuLi5wcm9wcyxcbiAgICBkYXRhOiB7XG4gICAgICAuLi5wcm9wcy5kYXRhLFxuICAgICAgc2VyaWVzOiBuZXdTZXJpZXMsXG4gICAgfSxcbiAgICBkYXRhU3BlYzoge1xuICAgICAgLi4ucHJvcHMuZGF0YVNwZWMsXG4gICAgICB5QXhpc0ZpZWxkczogbmV3WUF4aXNGaWVsZHMsXG4gICAgfSxcbiAgfTtcblxuICAvLyBMZWdlbmQgaXNuJ3Qgc3VwcG9ydGVkIHdoZW4gd2UgdXNlIGdyYWRpZW50IGNvbG9yaW5nXG4gIGlmIChyZW1vdmVMZWdlbmQpIHtcbiAgICBkZWxldGUgcHJvcHMubGVnZW5kO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jb25zdCBVaVNkbENhdGVnb3JpY2FsTGluZUJhckNoYXJ0OiBSZWFjdC5TRkM8UHJvcHM+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHVzZVRyYW5zbGF0ZShwcm9wcyk7XG4gIGxldCByZW1vdmVMZWdlbmQgPSBmYWxzZTtcblxuICBsZXQgc2VyaWVzID0gcHJvcHMuZGF0YT8uc2VyaWVzO1xuXG4gIGxldCBmaWVsZHMgPSBwcm9wcy5kYXRhU3BlYz8ueEF4aXNGaWVsZD8ucmVkaXJlY3RMaW5rPy5wYWdlVmFyaWFibGVGaWx0ZXJGaWVsZD8uc3BsaXQoJywnKTtcblxuICBmaWVsZHMgPSBmaWVsZHM/Lm1hcCgoZikgPT4gZi50cmltKCkpO1xuXG4gIGNvbnN0IHsgeEF4aXNGaWVsZE5hbWUsIHlBeGlzRmllbGROYW1lcyB9ID0gZ2V0QXhpc0ZpZWxkcyhwcm9wcy5kYXRhU3BlYyk7XG5cbiAgLy8gRmlsdGVyIG91dCBmaWVsZHMgdGhhdCBhcmUgYmVlaW5nIHVzZWQgYnkgdGhlIHlBeGlzRmllbGRzXG4gIGZpZWxkcyA9IGZpZWxkcz8uZmlsdGVyKChmKSA9PiAheUF4aXNGaWVsZE5hbWVzLmluY2x1ZGVzKGYpKTtcblxuICBsZXQgeUluZGV4T2Zmc2V0ID0gMDtcblxuICAvKipcbiAgICogU29tZXRpbWVzIHRoZSB1cmwgd2lsbCByZXF1aXJlIGZpZWxkcyBub3Qgc3BlY2lmaWVkIGFzIGZpZWxkTmFtZSBpbiB0aGUgZGF0YSBzcGVjLlxuICAgKiBJZiB0aGlzIGlzIHRoZSBjYXNlLCB0aGUgcGFydGlhbGx5IGFwcGxpZWQgYWN0aW9uIHdpbGwgaGF2ZSByZXN1bHRlZCBpbiBtb3JlIHNlcmllc1xuICAgKiB0aGFuIHdlIG5lZWQgdG8gY29ycmVjdGx5IHBsb3QgdGhlIGNoYXJ0LiBXZSB1c2UgdGhpcyBibG9jayB0byBhc3NpZ24gdXJsIG1hcHBpbmdzXG4gICAqIGFuZCByZW1vdmUgYW55IHVubmVjZXNzYXJ5IHNlcmllcyBiZWZvcmUgcGxvdHRpbmcgYSBTRExDaGFydC5cbiAgICovXG4gIGlmIChmaWVsZHM/Lmxlbmd0aCkge1xuICAgIGlmIChmaWVsZHMuaW5jbHVkZXMoeEF4aXNGaWVsZE5hbWUpKSB7XG4gICAgICB5SW5kZXhPZmZzZXQgPSBmaWVsZHMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgeUluZGV4T2Zmc2V0ID0gZmllbGRzLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBpZiAoc2VyaWVzKSB7XG4gICAgY29uc3QgeUF4aXNGaWVsZHMgPSBwcm9wcy5kYXRhU3BlYy55QXhpc0ZpZWxkcztcbiAgICBjb25zdCBuZXdZQXhpc0ZpZWxkcyA9IFtdO1xuXG4gICAgbGV0IG5ld1NlcmllcyA9IGdldE5ld1NlcmllcyhzZXJpZXMsIHlJbmRleE9mZnNldCwgeUF4aXNGaWVsZHMsIHByb3BzLnJlbW92ZUV4dHJhU2VyaWVzLCBuZXdZQXhpc0ZpZWxkcywgcmVtb3ZlTGVnZW5kKTtcblxuICAgIHByb3BzID0ge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIC4uLnByb3BzLmRhdGEsXG4gICAgICAgIHNlcmllczogbmV3U2VyaWVzLFxuICAgICAgfSxcbiAgICAgIGRhdGFTcGVjOiB7XG4gICAgICAgIC4uLnByb3BzLmRhdGFTcGVjLFxuICAgICAgICB5QXhpc0ZpZWxkczogbmV3WUF4aXNGaWVsZHMsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICAvLyBMZWdlbmQgaXNuJ3Qgc3VwcG9ydGVkIHdoZW4gd2UgdXNlIGdyYWRpZW50IGNvbG9yaW5nXG4gICAgaWYgKHJlbW92ZUxlZ2VuZCkge1xuICAgICAgZGVsZXRlIHByb3BzLmxlZ2VuZDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtYXJrTGluZXMgPSBnZXRNYXJrTGluZXMocHJvcHMubWFya0xpbmVzRGF0YVNwZWMsIHByb3BzLm1hcmtMaW5lc0RhdGEpO1xuXG4gIHJldHVybiA8U0RMTGluZUJhckNoYXJ0IHsuLi5wcm9wc30gZ2VuZXJhdGVTZXJpZXNJZD17Z2VuZXJhdGVTZXJpZXNJZH0gdHJhbnNsYXRlPXt0cmFuc2xhdGV9IG1hcmtMaW5lcz17bWFya0xpbmVzfSAvPjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFVpU2RsQ2F0ZWdvcmljYWxMaW5lQmFyQ2hhcnQ7XG5leHBvcnQge2dldE1hcmtMaW5lcywgZ2V0QXhpc0ZpZWxkcywgZ2V0R3JhZGllbnRzLCBnZXROZXdTZXJpZXMsIHVwZGF0ZVByb3BzfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVRyYW5zbGF0ZSIsIlNETExpbmVCYXJDaGFydCIsImdlbmVyYXRlU2VyaWVzSWQiLCJncmFkc3RvcCIsIk1BUktfTElORV9JRCIsImdldE1hcmtMaW5lcyIsIm1hcmtMaW5lc0RhdGFTcGVjIiwibWFya0xpbmVzRGF0YSIsImNvbWJpbmVkTWFya0xpbmVzIiwibWFya0xpbmVzQ29uZmlnIiwiX21hcmtMaW5lc0RhdGFTcGVjJG1hIiwiZm9yRWFjaCIsIm1hcmtMaW5lQ29uZmlnIiwiX21hcmtMaW5lc0RhdGEkb2JqcyIsImVudGl0eUlkIiwiZmllbGROYW1lIiwibWFya0xpbmVEYXRhUG9pbnQiLCJwdXNoIiwib2JqcyIsIm1hcmtEYXRhIiwiaWQiLCJnZXRBeGlzRmllbGRzIiwiZGF0YVNwZWMiLCJfZGF0YVNwZWMkeEF4aXNGaWVsZCIsInhBeGlzRmllbGROYW1lIiwieEF4aXNGaWVsZCIsInRyaW0iLCJ5QXhpc0ZpZWxkTmFtZXMiLCJ5QXhpc0ZpZWxkcyIsIm1hcCIsImYiLCJfZiRmaWVsZE5hbWUiLCJnZXRHcmFkaWVudHMiLCJncmFkaWVudDEiLCJncmFkaWVudDIiLCJncmFkaWVudDMiLCJnZXROZXdTZXJpZXMiLCJzZXJpZXMiLCJ5SW5kZXhPZmZzZXQiLCJyZW1vdmVFeHRyYVNlcmllcyIsIm5ld1lBeGlzRmllbGRzIiwicmVtb3ZlTGVnZW5kIiwiZ3JhZGllbnRzIiwiX2dldF9fIiwiZmxhdE1hcCIsInMiLCJpbmQiLCJfeUF4aXNGaWVsZHMkaW5kIiwiZmlsdGVyT3V0IiwiY29sb3JDb25maWd1cmF0aW9uU3RyYXRlZ3kiLCJzdHJhdGVneSIsIndlaWdodGVkR3JhZGllbnQiLCJ3ZWlnaHRlZE1ldGhvZENvbmZpZyIsImdyYWRpZW50VHlwZSIsImdyYWRpZW50IiwiZGF0YSIsImQiLCJmaWx0ZXIiLCJsZW5ndGgiLCJ0aHJlc2hvbGRzIiwibnVtYmVyT2ZDb2xvcnMiLCJtaW5WYWwiLCJtaW5pbXVtIiwiTWF0aCIsIm1pbiIsIm1heFZhbCIsIm1heGltdW0iLCJtYXgiLCJzdGVwU2l6ZSIsImkiLCJ1bmlxdWVTb3J0ZWREYXRhIiwiU2V0Iiwic29ydCIsImEiLCJiIiwiZmxvb3IiLCJjb2xvckdyYWRpZW50Iiwic2xpY2UiLCJzdG9wcyIsImlucHV0Rm9ybWF0IiwiY29sb3JBcnJheSIsInNBcnJheSIsImhhc1ZhbHVlIiwiZmllbGRTdWZmaXgiLCJuZXdEYXRhIiwic3RhY2siLCJjb2xvciIsInRvU3RyaW5nIiwidXBkYXRlUHJvcHMiLCJwcm9wcyIsIm5ld1NlcmllcyIsImxlZ2VuZCIsIlVpU2RsQ2F0ZWdvcmljYWxMaW5lQmFyQ2hhcnQiLCJfcHJvcHMkZGF0YSIsIl9wcm9wcyRkYXRhU3BlYyIsIl9maWVsZHMiLCJfZmllbGRzMiIsIl9maWVsZHMzIiwidHJhbnNsYXRlIiwiZmllbGRzIiwicmVkaXJlY3RMaW5rIiwicGFnZVZhcmlhYmxlRmlsdGVyRmllbGQiLCJzcGxpdCIsImluY2x1ZGVzIiwibWFya0xpbmVzIiwiY3JlYXRlRWxlbWVudCIsIl9leHRlbmRzIiwiX2dldEdsb2JhbE9iamVjdCIsImdsb2JhbCIsImUiLCJ3aW5kb3ciLCJfUmV3aXJlTW9kdWxlSWRfXyIsIl9nZXRSZXdpcmVNb2R1bGVJZF9fIiwiZ2xvYmFsVmFyaWFibGUiLCJfXyQkR0xPQkFMX1JFV0lSRV9ORVhUX01PRFVMRV9JRF9fIiwiX2dldFJld2lyZVJlZ2lzdHJ5X18iLCJ0aGVHbG9iYWxWYXJpYWJsZSIsIl9fJCRHTE9CQUxfUkVXSVJFX1JFR0lTVFJZX18iLCJPYmplY3QiLCJjcmVhdGUiLCJfZ2V0UmV3aXJlRXhwb3J0c1JlZ2lzdHJ5X18iLCJfXyQkR0xPQkFMX1JFV0lSRV9FWFBPUlRTX1JFR0lTVFJZX18iLCJfc3luY19pbnRlcm5hbF9zdGF0ZV93aXRoX2V4cG9ydHNfXyIsIl9leHBvcnRzX3RvX3Jlc2V0X18iLCJNYXAiLCJfcmVjb3JkX2V4cG9ydF90b19yZXNldF9fIiwidmFyaWFibGVOYW1lIiwidmFsdWUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJleHBvcnRzIiwiaGFzIiwic2V0IiwiX3Jlc3RvcmVfZXhwb3J0c19fIiwiZW50cmllcyIsImNsZWFyIiwiX21heWJlX3VwZGF0ZV9leHBvcnRfXyIsIl9nZXRSZXdpcmVkRGF0YV9fIiwibW9kdWxlSWQiLCJyZWdpc3RyeSIsInJld2lyZURhdGEiLCJleHBvcnRzUmVnaXN0cnkiLCJyZWdpc3RlclJlc2V0QWxsIiwicmVzdG9yZUZ1bmMiLCJ2YWx1ZXMiLCJJTlRFTlRJT05BTF9VTkRFRklORUQiLCJfUmV3aXJlQVBJX18iLCJhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0IiwibmFtZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIl9zZXRfXyIsIl9yZXNldF9fIiwiX3dpdGhfXyIsInVuZGVmaW5lZCIsIl9nZXRfb3JpZ2luYWxfXyIsIl9maWx0ZXJXaWxkY2FyZEltcG9ydF9fIiwiX2Fzc2lnbl9fIiwiX3NldF9vcmlnaW5hbF9fIiwiX3ZhbHVlIiwiX3VwZGF0ZV9vcGVyYXRpb25fXyIsIm9wZXJhdGlvbiIsInByZWZpeCIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJrZXlzIiwiZ2V0IiwiZGVsZXRlIiwib2JqZWN0IiwicmV3aXJlZFZhcmlhYmxlTmFtZXMiLCJwcmV2aW91c1ZhbHVlcyIsInJlc2V0IiwiY2FsbGJhY2siLCJyZXN1bHQiLCJ0aGVuIiwiY2F0Y2giLCJfdHlwZU9mT3JpZ2luYWxFeHBvcnQiLCJhZGROb25FbnVtZXJhYmxlUHJvcGVydHkiLCJpc0V4dGVuc2libGUiLCJ3aWxkY2FyZEltcG9ydCIsInZhbGlkUHJvcGVydHlOYW1lcyIsInByb3BlcnR5TmFtZSIsInJlZHVjZSIsImZpbHRlcmVkV2lsZGNhcmRJbXBvcnQiLCJfX2dldF9fIiwiX19HZXREZXBlbmRlbmN5X18iLCJfX1Jld2lyZV9fIiwiX19zZXRfXyIsIl9fUmVzZXREZXBlbmRlbmN5X18iLCJfX1Jld2lyZUFQSV9fIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@c3/ui/UiSdlCategoricalLineBarChartReact.tsx_uiComponentLibraryReact\n");

/***/ }),

/***/ "./node_modules/gradstop/dist/index.js_uiComponentLibraryReact":
/*!*********************************************!*\
  !*** ./node_modules/gradstop/dist/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _utils = __webpack_require__(/*! ./utils */ "./node_modules/gradstop/dist/utils.js_uiComponentLibraryReact");

var defaultOptions = {
  // input color options: hex, rgb or hsl
  inputFormat: 'hex',
  // number of color stops (cannot be less than colorArray.length)
  stops: 5,
  // input color array
  colorArray: ['#fff', '#000']
};

function gradstop(options) {
  options = _extends({}, defaultOptions, options);
  (0, _utils.handleErrors)(options);
  var stops = (0, _utils.getStops)(options);
  return stops;
}

module.exports = gradstop;

/***/ }),

/***/ "./node_modules/gradstop/dist/utils.js_uiComponentLibraryReact":
/*!*********************************************!*\
  !*** ./node_modules/gradstop/dist/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var handleErrors = exports.handleErrors = function handleErrors(options) {
  var inputFormat = options.inputFormat,
      stops = options.stops,
      colorArray = options.colorArray;


  if (typeof inputFormat !== 'string') {
    throw 'inputFormat should be a string';
  }

  var supportedFormats = ['hex', 'rgb', 'hsl'];
  var isValidFormat = supportedFormats.indexOf(inputFormat.toLowerCase()) !== -1;
  if (!isValidFormat) {
    throw 'Invalid inputFormat value, supported: hex, rgb and hsl';
  }

  if (!Number.isInteger(stops)) {
    throw 'stops should be an integer';
  }

  if (!Array.isArray(colorArray) || !colorArray.every(function (item) {
    return typeof item === 'string';
  })) {
    throw 'colorArray should be an array of color strings';
  }

  if (stops < colorArray.length) {
    throw 'Number of stops cannot be less than colorArray.length';
  }
};

var hexToRgb = exports.hexToRgb = function hexToRgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

  var _result$map = result.map(function (val) {
    return parseInt(val, 16);
  }),
      _result$map2 = _slicedToArray(_result$map, 4),
      r = _result$map2[1],
      g = _result$map2[2],
      b = _result$map2[3];

  return result ? { r: r, g: g, b: b } : null;
};

// if hex and defined as #fff then convert it to standard 7 letter format #ffffff
var standardizeHexValues = exports.standardizeHexValues = function standardizeHexValues(arrayOfHexStrings) {
  return arrayOfHexStrings.map(function (str) {
    if (str.length === 4) {
      return '#' + (str[1] + str[1] + str[2] + str[2] + str[3] + str[3]);
    } else if (str.length === 7) {
      return str;
    }
  });
};

var extractHEX = exports.extractHEX = function extractHEX(arrayOfHexStrings) {
  return standardizeHexValues(arrayOfHexStrings).map(function (str) {
    return hexToRgb(str);
  });
};

var extractRGB = exports.extractRGB = function extractRGB(arrayOfRGBStrings) {
  return arrayOfRGBStrings.map(function (str) {
    var _str$match = str.match(/\d+/g),
        _str$match2 = _slicedToArray(_str$match, 3),
        r = _str$match2[0],
        g = _str$match2[1],
        b = _str$match2[2];

    return { r: Number(r), g: Number(g), b: Number(b) };
  });
};

var extractHSL = exports.extractHSL = function extractHSL(arrayOfHSLStrings) {
  return arrayOfHSLStrings.map(function (str) {
    var _str$match3 = str.match(/\d+/g),
        _str$match4 = _slicedToArray(_str$match3, 3),
        h = _str$match4[0],
        s = _str$match4[1],
        l = _str$match4[2];

    return { h: Number(h), s: Number(s), l: Number(l) };
  });
};

var getRGBString = exports.getRGBString = function getRGBString(_ref) {
  var r = _ref.r,
      g = _ref.g,
      b = _ref.b;
  return 'rgb(' + r + ', ' + g + ', ' + b + ')';
};
var getHSLString = exports.getHSLString = function getHSLString(_ref2) {
  var h = _ref2.h,
      s = _ref2.s,
      l = _ref2.l;
  return 'hsl(' + h + ', ' + s + '%, ' + l + '%)';
};

// get r,g,b,h,s and l with Bezier interpolation
// https://www.cl.cam.ac.uk/teaching/2000/AGraphHCI/SMEG/node3.html
// Check issue #3 for more info
var bezierInterpolation = function bezierInterpolation(colorTypeChars) {
  return function (colArr, x) {
    var y = 1 - x;
    var v = void 0;
    return colorTypeChars.reduce(function (colorObject, char) {
      if (colArr.length === 2) {
        v = y * colArr[0][char] + x * colArr[1][char];
      } else if (colArr.length === 3) {
        v = Math.pow(y, 2) * colArr[0][char] + 2 * y * x * colArr[1][char] + Math.pow(x, 2) * colArr[2][char];
      } else if (colArr.length === 4) {
        v = Math.pow(y, 3) * colArr[0][char] + 3 * Math.pow(y, 2) * x * colArr[1][char] + 3 * y * Math.pow(x, 2) * colArr[2][char] + Math.pow(x, 3) * colArr[3][char];
      }
      colorObject[char] = Math.trunc(v);
      return colorObject;
    }, {});
  };
};

var rgbBezierInterpolation = bezierInterpolation(['r', 'g', 'b']);
var hslBezierInterpolation = bezierInterpolation(['h', 's', 'l']);

var transformColorStringsToObjects = function transformColorStringsToObjects(options) {
  switch (options.inputFormat) {
    case 'hex':
      return extractHEX(options.colorArray);
    case 'rgb':
      return extractRGB(options.colorArray);
    case 'hsl':
      return extractHSL(options.colorArray);
  }
};

var stopsGenerator = function stopsGenerator(options) {
  var outputArray = [];
  var increment = 1.0 / (options.stops - 1);

  for (var i = 0; i < options.stops; i++) {
    if (options.inputFormat === 'hex' || options.inputFormat === 'rgb') {
      var rgbObject = rgbBezierInterpolation(options.colorArray, increment * i);
      outputArray.push(getRGBString(rgbObject));
    } else if (options.inputFormat === 'hsl') {
      var hslObject = hslBezierInterpolation(options.colorArray, increment * i);
      outputArray.push(getHSLString(hslObject));
    }
  }

  return outputArray;
};

var getStops = exports.getStops = function getStops(options) {
  var colorArray = transformColorStringsToObjects(options);
  var optionsWithFormattedColorsValues = _extends({}, options, { colorArray: colorArray });
  return stopsGenerator(optionsWithFormattedColorsValues);
};

/***/ }),

/***/ "./node_modules/gradstop/index.js_uiComponentLibraryReact":
/*!****************************************!*\
  !*** ./node_modules/gradstop/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./dist */ "./node_modules/gradstop/dist/index.js_uiComponentLibraryReact");

/***/ })

}]);