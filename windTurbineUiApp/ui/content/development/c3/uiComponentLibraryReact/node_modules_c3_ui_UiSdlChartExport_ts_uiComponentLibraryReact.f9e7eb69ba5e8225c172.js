/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkjs_webpack_c3_client_node"] = self["webpackChunkjs_webpack_c3_client_node"] || []).push([["node_modules_c3_ui_UiSdlChartExport_ts_uiComponentLibraryReact"],{

/***/ "./node_modules/@c3/ui/UiSdlChartExport.ts_uiComponentLibraryReact":
/*!*************************************************!*\
  !*** ./node_modules/@c3/ui/UiSdlChartExport.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __GetDependency__: () => (/* binding */ _get__),\n/* harmony export */   __ResetDependency__: () => (/* binding */ _reset__),\n/* harmony export */   __RewireAPI__: () => (/* binding */ _RewireAPI__),\n/* harmony export */   __Rewire__: () => (/* binding */ _set__),\n/* harmony export */   __get__: () => (/* binding */ _get__),\n/* harmony export */   __set__: () => (/* binding */ _set__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   defaultValues: () => (/* binding */ defaultValues)\n/* harmony export */ });\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! file-saver */ \"./node_modules/file-saver/FileSaver.js_uiComponentLibraryReact\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var html_to_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! html-to-image */ \"./node_modules/html-to-image/es/index.js_uiComponentLibraryReact\");\n/* harmony import */ var _c3_ui_UiSdlLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @c3/ui/UiSdlLogger */ \"webpack/container/remote/@c3/ui/UiSdlLogger_uiComponentLibraryReact\");\n/* harmony import */ var _c3_ui_UiSdlLogger__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_c3_ui_UiSdlLogger__WEBPACK_IMPORTED_MODULE_2__);\n/*\n * Copyright 2009-2024 C3 AI (www.c3.ai). All Rights Reserved.\n * This material, including without limitation any software, is the confidential trade secret and proprietary\n * information of C3 and its licensors. Reproduction, use and/or distribution of this material in any form is\n * strictly prohibited except as set forth in a written license agreement with C3 and/or its authorized distributors.\n * This material may be covered by one or more patents or pending patent applications.\n */\n\n\n\n\nconst logger = _get__(\"withName\")('UiSdlChartExport');\nfunction dataUriToBlob(dataUri) {\n  const byteString = atob(dataUri.split(',')[1]);\n\n  // Separate out the mime component\n  const mimeString = dataUri.split(',')[0].split(':')[1].split(';')[0];\n\n  // Write the bytes of the string to an ArrayBuffer\n  const ab = new ArrayBuffer(byteString.length);\n\n  // Create a view into the buffer\n  const ia = new Uint8Array(ab);\n\n  // Set the bytes of the buffer to the correct values\n  for (let i = 0; i < byteString.length; i++) {\n    ia[i] = byteString.charCodeAt(i);\n  }\n\n  // Write the ArrayBuffer to a blob, and you're done\n  return new Blob([ab], {\n    type: mimeString\n  });\n}\n\n/**\n * Higher-order function which accepts a chart exporter callback and wraps it with error handling logic.\n * @param {AsyncChartExporter} exporter An async exporter function.\n * @returns {AsyncChartExporter} an async exporter function with error handling logic.\n */\nconst handleAsyncExportErrors = asyncExporter => exportableElement => {\n  if (!exportableElement) {\n    _get__(\"logger\")('uiSdlReact.SDLChart').error('Could not export chart to image; the chart element was not mounted.');\n    return;\n  }\n  try {\n    return asyncExporter.call(null, exportableElement);\n  } catch (error) {\n    _get__(\"logger\")('uiSdlReact.SDLChart').error('Could not export chart to image; see below for error message.');\n    return Promise.reject(error);\n  }\n};\n\n/**\n * Generates a PNG image of the given chart.\n * @param {HTMLElement | undefined} [exportableElement] The HTML element to export.\n */\nconst exportPng = _get__(\"handleAsyncExportErrors\")(async exportableElement => {\n  const dataUri = await _get__(\"toPng\")(exportableElement);\n  const blob = _get__(\"dataUriToBlob\")(dataUri);\n  _get__(\"FileSaver\").saveAs(blob, 'chart.png');\n});\n\n/**\n * Generates a JPEG image of the given chart.\n * @param {HTMLElement | undefined} [exportableElement] The HTML element to export.\n */\nconst exportJpeg = _get__(\"handleAsyncExportErrors\")(async exportableElement => {\n  const dataUri = await _get__(\"toJpeg\")(exportableElement);\n  const blob = _get__(\"dataUriToBlob\")(dataUri);\n  _get__(\"FileSaver\").saveAs(blob, 'chart.jpeg');\n});\n\n/**\n * Generates a CSV file with the data for the given set of series.\n * @param {Function} getExportCsvData A function that gets the series data to convert to CSV.\n */\nfunction exportCsv(getExportCsvData) {\n  const fileName = 'data.csv';\n  const csvFile = getExportCsvData();\n  const blob = new Blob([csvFile], {\n    type: 'text/plain;charset=utf-8'\n  });\n  _get__(\"FileSaver\").saveAs(blob, fileName);\n}\nlet _DefaultExportValue = {\n  exportPng: _get__(\"exportPng\"),\n  exportJpeg: _get__(\"exportJpeg\"),\n  exportCsv: _get__(\"exportCsv\"),\n  dataUriToBlob: _get__(\"dataUriToBlob\")\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_DefaultExportValue);\nconst defaultValues = {\n  \"chartActionsDefault\": [{\n    \"name\": \"EXPORT_CHART_CSV\",\n    \"actionSuffix\": \"EXPORT_CHART_CSV\",\n    \"iconSuffix\": \"table\"\n  }, {\n    \"name\": \"EXPORT_CHART_JPEG\",\n    \"actionSuffix\": \"EXPORT_CHART_JPEG\",\n    \"iconSuffix\": \"file-image\"\n  }, {\n    \"name\": \"EXPORT_CHART_PNG\",\n    \"actionSuffix\": \"EXPORT_CHART_PNG\",\n    \"iconSuffix\": \"file-image\"\n  }]\n};\nfunction _getGlobalObject() {\n  try {\n    if (!!__webpack_require__.g) {\n      return __webpack_require__.g;\n    }\n  } catch (e) {\n    try {\n      if (!!window) {\n        return window;\n      }\n    } catch (e) {\n      return this;\n    }\n  }\n}\n;\nvar _RewireModuleId__ = null;\nfunction _getRewireModuleId__() {\n  if (_RewireModuleId__ === null) {\n    let globalVariable = _getGlobalObject();\n    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {\n      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;\n    }\n    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;\n  }\n  return _RewireModuleId__;\n}\nfunction _getRewireRegistry__() {\n  let theGlobalVariable = _getGlobalObject();\n  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {\n    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);\n  }\n  return theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__;\n}\nfunction _getRewireExportsRegistry__() {\n  let theGlobalVariable = _getGlobalObject();\n  if (!theGlobalVariable.__$$GLOBAL_REWIRE_EXPORTS_REGISTRY__) {\n    theGlobalVariable.__$$GLOBAL_REWIRE_EXPORTS_REGISTRY__ = Object.create(null);\n  }\n  return theGlobalVariable.__$$GLOBAL_REWIRE_EXPORTS_REGISTRY__;\n}\nconst _sync_internal_state_with_exports__ = false;\nconst _exports_to_reset__ = new Map();\nfunction _record_export_to_reset__(variableName, value) {\n  if (!_sync_internal_state_with_exports__) {\n    return;\n  }\n  if (!Object.prototype.hasOwnProperty.call(exports, variableName)) {\n    return;\n  }\n  if (!_exports_to_reset__.has(variableName)) {\n    _exports_to_reset__.set(variableName, value);\n  }\n}\nfunction _restore_exports__() {\n  const entries = _exports_to_reset__.entries();\n  for (const [variableName, value] of entries) {\n    exports[variableName] = value;\n  }\n  _exports_to_reset__.clear();\n}\nfunction _maybe_update_export__(variableName, value) {\n  if (!_sync_internal_state_with_exports__) {\n    return;\n  }\n  if (!Object.prototype.hasOwnProperty.call(exports, variableName)) {\n    return;\n  }\n  _record_export_to_reset__(variableName, exports[variableName]);\n  exports[variableName] = value;\n}\nfunction _getRewiredData__() {\n  let moduleId = _getRewireModuleId__();\n  let registry = _getRewireRegistry__();\n  let rewireData = registry[moduleId];\n  if (!rewireData) {\n    registry[moduleId] = Object.create(null);\n    rewireData = registry[moduleId];\n  }\n  let exportsRegistry = _getRewireExportsRegistry__();\n  if (!exportsRegistry[moduleId]) {\n    exportsRegistry[moduleId] = _restore_exports__;\n  }\n  return rewireData;\n}\n(function registerResetAll() {\n  let theGlobalVariable = _getGlobalObject();\n  if (!theGlobalVariable['__rewire_reset_all__']) {\n    theGlobalVariable['__rewire_reset_all__'] = function () {\n      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);\n      const exportsRegistry = _getRewireExportsRegistry__();\n      for (const restoreFunc of Object.values(exportsRegistry)) {\n        restoreFunc();\n      }\n      theGlobalVariable.__$$GLOBAL_REWIRE_EXPORTS_REGISTRY__ = Object.create(null);\n    };\n  }\n})();\nvar INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';\nlet _RewireAPI__ = {};\n(function () {\n  function addPropertyToAPIObject(name, value) {\n    Object.defineProperty(_RewireAPI__, name, {\n      value: value,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  addPropertyToAPIObject('__get__', _get__);\n  addPropertyToAPIObject('__GetDependency__', _get__);\n  addPropertyToAPIObject('__Rewire__', _set__);\n  addPropertyToAPIObject('__set__', _set__);\n  addPropertyToAPIObject('__reset__', _reset__);\n  addPropertyToAPIObject('__ResetDependency__', _reset__);\n  addPropertyToAPIObject('__with__', _with__);\n})();\nfunction _get__(variableName) {\n  let rewireData = _getRewiredData__();\n  if (rewireData[variableName] === undefined) {\n    return _get_original__(variableName);\n  } else {\n    var value = rewireData[variableName];\n    if (value === INTENTIONAL_UNDEFINED) {\n      return undefined;\n    } else {\n      return value;\n    }\n  }\n}\nfunction _get_original__(variableName) {\n  switch (variableName) {\n    case \"withName\":\n      return _c3_ui_UiSdlLogger__WEBPACK_IMPORTED_MODULE_2__.withName;\n    case \"logger\":\n      return logger;\n    case \"handleAsyncExportErrors\":\n      return handleAsyncExportErrors;\n    case \"toPng\":\n      return html_to_image__WEBPACK_IMPORTED_MODULE_1__.toPng;\n    case \"dataUriToBlob\":\n      return dataUriToBlob;\n    case \"FileSaver\":\n      return _filterWildcardImport__(file_saver__WEBPACK_IMPORTED_MODULE_0__);\n    case \"toJpeg\":\n      return html_to_image__WEBPACK_IMPORTED_MODULE_1__.toJpeg;\n    case \"exportPng\":\n      return exportPng;\n    case \"exportJpeg\":\n      return exportJpeg;\n    case \"exportCsv\":\n      return exportCsv;\n  }\n  return undefined;\n}\nfunction _assign__(variableName, value) {\n  let rewireData = _getRewiredData__();\n  if (rewireData[variableName] === undefined) {\n    return _set_original__(variableName, value);\n  } else {\n    _maybe_update_export__(variableName, value);\n    return rewireData[variableName] = value;\n  }\n}\nfunction _set_original__(variableName, _value) {\n  switch (variableName) {}\n  return undefined;\n}\nfunction _update_operation__(operation, variableName, prefix) {\n  var oldValue = _get__(variableName);\n  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;\n  _assign__(variableName, newValue);\n  return prefix ? newValue : oldValue;\n}\nfunction _set__(variableName, value) {\n  let rewireData = _getRewiredData__();\n  if (typeof variableName === 'object') {\n    Object.keys(variableName).forEach(function (name) {\n      rewireData[name] = variableName[name];\n    });\n    return function () {\n      Object.keys(variableName).forEach(function (name) {\n        _reset__(variableName);\n      });\n    };\n  } else {\n    _maybe_update_export__(variableName, value);\n    if (value === undefined) {\n      rewireData[variableName] = INTENTIONAL_UNDEFINED;\n    } else {\n      rewireData[variableName] = value;\n    }\n    return function () {\n      _reset__(variableName);\n    };\n  }\n}\nfunction _reset__(variableName) {\n  let rewireData = _getRewiredData__();\n  delete rewireData[variableName];\n  if (Object.keys(rewireData).length == 0) {\n    delete _getRewireRegistry__()[_getRewireModuleId__];\n  }\n  if (_exports_to_reset__.has(variableName)) {\n    exports[variableName] = _exports_to_reset__.get(variableName);\n    _exports_to_reset__.delete(variableName);\n  }\n}\nfunction _with__(object) {\n  let rewireData = _getRewiredData__();\n  var rewiredVariableNames = Object.keys(object);\n  var previousValues = {};\n  function reset() {\n    rewiredVariableNames.forEach(function (variableName) {\n      rewireData[variableName] = previousValues[variableName];\n    });\n  }\n  return function (callback) {\n    rewiredVariableNames.forEach(function (variableName) {\n      previousValues[variableName] = rewireData[variableName];\n      rewireData[variableName] = object[variableName];\n    });\n    let result = callback();\n    if (!!result && typeof result.then == 'function') {\n      result.then(reset).catch(reset);\n    } else {\n      reset();\n    }\n    return result;\n  };\n}\nlet _typeOfOriginalExport = typeof _DefaultExportValue;\nfunction addNonEnumerableProperty(name, value) {\n  Object.defineProperty(_DefaultExportValue, name, {\n    value: value,\n    enumerable: false,\n    configurable: true\n  });\n}\nif ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(_DefaultExportValue)) {\n  addNonEnumerableProperty('__get__', _get__);\n  addNonEnumerableProperty('__GetDependency__', _get__);\n  addNonEnumerableProperty('__Rewire__', _set__);\n  addNonEnumerableProperty('__set__', _set__);\n  addNonEnumerableProperty('__reset__', _reset__);\n  addNonEnumerableProperty('__ResetDependency__', _reset__);\n  addNonEnumerableProperty('__with__', _with__);\n  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);\n}\nfunction _filterWildcardImport__(wildcardImport = {}) {\n  let validPropertyNames = Object.keys(wildcardImport).filter(function (propertyName) {\n    return propertyName !== '__get__' && propertyName !== '__set__' && propertyName !== '__reset__' && propertyName !== '__with__' && propertyName !== '__GetDependency__' && propertyName !== '__Rewire__' && propertyName !== '__ResetDependency__';\n  });\n  return validPropertyNames.reduce(function (filteredWildcardImport, propertyName) {\n    filteredWildcardImport[propertyName] = wildcardImport[propertyName];\n    return filteredWildcardImport;\n  }, {});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGMzL3VpL1VpU2RsQ2hhcnRFeHBvcnQudHNfdWlDb21wb25lbnRMaWJyYXJ5UmVhY3QiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QztBQUNNO0FBQ0E7QUFFOUMsTUFBTUksTUFBTSxHQUFHQyxNQUFBLGFBQVMsa0JBQWtCLENBQUM7QUFFM0MsU0FBU0MsYUFBYUEsQ0FBQ0MsT0FBZSxFQUFRO0VBQzVDLE1BQU1DLFVBQVUsR0FBR0MsSUFBSSxDQUFDRixPQUFPLENBQUNHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7RUFFOUM7RUFDQSxNQUFNQyxVQUFVLEdBQUdKLE9BQU8sQ0FBQ0csS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDQSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUNBLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7O0VBRXBFO0VBQ0EsTUFBTUUsRUFBRSxHQUFHLElBQUlDLFdBQVcsQ0FBQ0wsVUFBVSxDQUFDTSxNQUFNLENBQUM7O0VBRTdDO0VBQ0EsTUFBTUMsRUFBRSxHQUFHLElBQUlDLFVBQVUsQ0FBQ0osRUFBRSxDQUFDOztFQUU3QjtFQUNBLEtBQUssSUFBSUssQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHVCxVQUFVLENBQUNNLE1BQU0sRUFBRUcsQ0FBQyxFQUFFLEVBQUU7SUFDMUNGLEVBQUUsQ0FBQ0UsQ0FBQyxDQUFDLEdBQUdULFVBQVUsQ0FBQ1UsVUFBVSxDQUFDRCxDQUFDLENBQUM7RUFDbEM7O0VBRUE7RUFDQSxPQUFPLElBQUlFLElBQUksQ0FBQyxDQUFDUCxFQUFFLENBQUMsRUFBRTtJQUFFUSxJQUFJLEVBQUVUO0VBQVcsQ0FBQyxDQUFDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFN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Y0FBQSxDQUFBNUMsbUJBQUEsRUFBQTJDLElBQUE7SUFBQXJCLEtBQUEsRUFBQUEsS0FBQTtJQUFBdUIsVUFBQTtJQUFBQyxZQUFBO0VBQUE7QUFBQTtBQUFBLEtBQUEyQixxQkFBQSxpQkFBQUEscUJBQUEsb0JBQUE1RCxNQUFBLENBQUE4RCxZQUFBLENBQUEzRSxtQkFBQTtFQUFBMEUsd0JBQUEsWUFBQXpHLE1BQUE7RUFBQXlHLHdCQUFBLHNCQUFBekcsTUFBQTtFQUFBeUcsd0JBQUEsZUFBQTNCLE1BQUE7RUFBQTJCLHdCQUFBLFlBQUEzQixNQUFBO0VBQUEyQix3QkFBQSxjQUFBMUIsUUFBQTtFQUFBMEIsd0JBQUEsd0JBQUExQixRQUFBO0VBQUEwQix3QkFBQSxhQUFBekIsT0FBQTtFQUFBeUIsd0JBQUEsa0JBQUFqQyxZQUFBO0FBQUE7QUFBQSxTQUFBVyx3QkFBQXdCLGNBQUE7RUFBQSxJQUFBQyxrQkFBQSxHQUFBaEUsTUFBQSxDQUFBZ0QsSUFBQSxDQUFBZSxjQUFBLEVBQUFFLE1BQUEsV0FBQUMsWUFBQTtJQUFBLE9BQUFBLFlBQUEsa0JBQUFBLFlBQUEsa0JBQUFBLFlBQUEsb0JBQUFBLFlBQUEsbUJBQUFBLFlBQUEsNEJBQUFBLFlBQUEscUJBQUFBLFlBQUE7RUFBQTtFQUFBLE9BQUFGLGtCQUFBLENBQUFHLE1BQUEsV0FBQUMsc0JBQUEsRUFBQUYsWUFBQTtJQUFBRSxzQkFBQSxDQUFBRixZQUFBLElBQUFILGNBQUEsQ0FBQUcsWUFBQTtJQUFBLE9BQUFFLHNCQUFBO0VBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpQ29tcG9uZW50TGlicmFyeVJlYWN0Ly4vbm9kZV9tb2R1bGVzL0BjMy91aS9VaVNkbENoYXJ0RXhwb3J0LnRzP2E2MzMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMjQgQzMgQUkgKHd3dy5jMy5haSkuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIG1hdGVyaWFsLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIGFueSBzb2Z0d2FyZSwgaXMgdGhlIGNvbmZpZGVudGlhbCB0cmFkZSBzZWNyZXQgYW5kIHByb3ByaWV0YXJ5XG4gKiBpbmZvcm1hdGlvbiBvZiBDMyBhbmQgaXRzIGxpY2Vuc29ycy4gUmVwcm9kdWN0aW9uLCB1c2UgYW5kL29yIGRpc3RyaWJ1dGlvbiBvZiB0aGlzIG1hdGVyaWFsIGluIGFueSBmb3JtIGlzXG4gKiBzdHJpY3RseSBwcm9oaWJpdGVkIGV4Y2VwdCBhcyBzZXQgZm9ydGggaW4gYSB3cml0dGVuIGxpY2Vuc2UgYWdyZWVtZW50IHdpdGggQzMgYW5kL29yIGl0cyBhdXRob3JpemVkIGRpc3RyaWJ1dG9ycy5cbiAqIFRoaXMgbWF0ZXJpYWwgbWF5IGJlIGNvdmVyZWQgYnkgb25lIG9yIG1vcmUgcGF0ZW50cyBvciBwZW5kaW5nIHBhdGVudCBhcHBsaWNhdGlvbnMuXG4gKi9cblxuaW1wb3J0ICogYXMgRmlsZVNhdmVyIGZyb20gJ2ZpbGUtc2F2ZXInO1xuaW1wb3J0IHsgdG9QbmcsIHRvSnBlZyB9IGZyb20gJ2h0bWwtdG8taW1hZ2UnO1xuaW1wb3J0IHsgd2l0aE5hbWUgfSBmcm9tICdAYzMvdWkvVWlTZGxMb2dnZXInO1xuXG5jb25zdCBsb2dnZXIgPSB3aXRoTmFtZSgnVWlTZGxDaGFydEV4cG9ydCcpO1xuXG5mdW5jdGlvbiBkYXRhVXJpVG9CbG9iKGRhdGFVcmk6IHN0cmluZyk6IEJsb2Ige1xuICBjb25zdCBieXRlU3RyaW5nID0gYXRvYihkYXRhVXJpLnNwbGl0KCcsJylbMV0pO1xuXG4gIC8vIFNlcGFyYXRlIG91dCB0aGUgbWltZSBjb21wb25lbnRcbiAgY29uc3QgbWltZVN0cmluZyA9IGRhdGFVcmkuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF07XG5cbiAgLy8gV3JpdGUgdGhlIGJ5dGVzIG9mIHRoZSBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXJcbiAgY29uc3QgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuXG4gIC8vIENyZWF0ZSBhIHZpZXcgaW50byB0aGUgYnVmZmVyXG4gIGNvbnN0IGlhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXG4gIC8vIFNldCB0aGUgYnl0ZXMgb2YgdGhlIGJ1ZmZlciB0byB0aGUgY29ycmVjdCB2YWx1ZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgaWFbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICAvLyBXcml0ZSB0aGUgQXJyYXlCdWZmZXIgdG8gYSBibG9iLCBhbmQgeW91J3JlIGRvbmVcbiAgcmV0dXJuIG5ldyBCbG9iKFthYl0sIHsgdHlwZTogbWltZVN0cmluZyB9KTtcbn1cblxuLyoqXG4gKiBIaWdoZXItb3JkZXIgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBhIGNoYXJ0IGV4cG9ydGVyIGNhbGxiYWNrIGFuZCB3cmFwcyBpdCB3aXRoIGVycm9yIGhhbmRsaW5nIGxvZ2ljLlxuICogQHBhcmFtIHtBc3luY0NoYXJ0RXhwb3J0ZXJ9IGV4cG9ydGVyIEFuIGFzeW5jIGV4cG9ydGVyIGZ1bmN0aW9uLlxuICogQHJldHVybnMge0FzeW5jQ2hhcnRFeHBvcnRlcn0gYW4gYXN5bmMgZXhwb3J0ZXIgZnVuY3Rpb24gd2l0aCBlcnJvciBoYW5kbGluZyBsb2dpYy5cbiAqL1xuY29uc3QgaGFuZGxlQXN5bmNFeHBvcnRFcnJvcnMgPSAoYXN5bmNFeHBvcnRlcikgPT4gKGV4cG9ydGFibGVFbGVtZW50KSA9PiB7XG4gIGlmICghZXhwb3J0YWJsZUVsZW1lbnQpIHtcbiAgICBsb2dnZXIoJ3VpU2RsUmVhY3QuU0RMQ2hhcnQnKS5lcnJvcignQ291bGQgbm90IGV4cG9ydCBjaGFydCB0byBpbWFnZTsgdGhlIGNoYXJ0IGVsZW1lbnQgd2FzIG5vdCBtb3VudGVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGFzeW5jRXhwb3J0ZXIuY2FsbChudWxsLCBleHBvcnRhYmxlRWxlbWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyKCd1aVNkbFJlYWN0LlNETENoYXJ0JykuZXJyb3IoJ0NvdWxkIG5vdCBleHBvcnQgY2hhcnQgdG8gaW1hZ2U7IHNlZSBiZWxvdyBmb3IgZXJyb3IgbWVzc2FnZS4nKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIFBORyBpbWFnZSBvZiB0aGUgZ2l2ZW4gY2hhcnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgdW5kZWZpbmVkfSBbZXhwb3J0YWJsZUVsZW1lbnRdIFRoZSBIVE1MIGVsZW1lbnQgdG8gZXhwb3J0LlxuICovXG5jb25zdCBleHBvcnRQbmcgPSBoYW5kbGVBc3luY0V4cG9ydEVycm9ycyhhc3luYyAoZXhwb3J0YWJsZUVsZW1lbnQpID0+IHtcbiAgY29uc3QgZGF0YVVyaSA9IGF3YWl0IHRvUG5nKGV4cG9ydGFibGVFbGVtZW50KTtcbiAgY29uc3QgYmxvYiA9IGRhdGFVcmlUb0Jsb2IoZGF0YVVyaSk7XG4gIEZpbGVTYXZlci5zYXZlQXMoYmxvYiwgJ2NoYXJ0LnBuZycpO1xufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgSlBFRyBpbWFnZSBvZiB0aGUgZ2l2ZW4gY2hhcnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgdW5kZWZpbmVkfSBbZXhwb3J0YWJsZUVsZW1lbnRdIFRoZSBIVE1MIGVsZW1lbnQgdG8gZXhwb3J0LlxuICovXG5jb25zdCBleHBvcnRKcGVnID0gaGFuZGxlQXN5bmNFeHBvcnRFcnJvcnMoYXN5bmMgKGV4cG9ydGFibGVFbGVtZW50KSA9PiB7XG4gIGNvbnN0IGRhdGFVcmkgPSBhd2FpdCB0b0pwZWcoZXhwb3J0YWJsZUVsZW1lbnQpO1xuICBjb25zdCBibG9iID0gZGF0YVVyaVRvQmxvYihkYXRhVXJpKTtcbiAgRmlsZVNhdmVyLnNhdmVBcyhibG9iLCAnY2hhcnQuanBlZycpO1xufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgQ1NWIGZpbGUgd2l0aCB0aGUgZGF0YSBmb3IgdGhlIGdpdmVuIHNldCBvZiBzZXJpZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRFeHBvcnRDc3ZEYXRhIEEgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBzZXJpZXMgZGF0YSB0byBjb252ZXJ0IHRvIENTVi5cbiAqL1xuZnVuY3Rpb24gZXhwb3J0Q3N2KGdldEV4cG9ydENzdkRhdGE6ICgpID0+IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCBmaWxlTmFtZSA9ICdkYXRhLmNzdic7XG4gIGNvbnN0IGNzdkZpbGUgPSBnZXRFeHBvcnRDc3ZEYXRhKCk7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY3N2RmlsZV0sIHsgdHlwZTogJ3RleHQvcGxhaW47Y2hhcnNldD11dGYtOCcgfSk7XG4gIEZpbGVTYXZlci5zYXZlQXMoYmxvYiwgZmlsZU5hbWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IGV4cG9ydFBuZywgZXhwb3J0SnBlZywgZXhwb3J0Q3N2LCBkYXRhVXJpVG9CbG9iIH07XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0VmFsdWVzID0ge1wiY2hhcnRBY3Rpb25zRGVmYXVsdFwiOlt7XCJuYW1lXCI6XCJFWFBPUlRfQ0hBUlRfQ1NWXCIsXCJhY3Rpb25TdWZmaXhcIjpcIkVYUE9SVF9DSEFSVF9DU1ZcIixcImljb25TdWZmaXhcIjpcInRhYmxlXCJ9LHtcIm5hbWVcIjpcIkVYUE9SVF9DSEFSVF9KUEVHXCIsXCJhY3Rpb25TdWZmaXhcIjpcIkVYUE9SVF9DSEFSVF9KUEVHXCIsXCJpY29uU3VmZml4XCI6XCJmaWxlLWltYWdlXCJ9LHtcIm5hbWVcIjpcIkVYUE9SVF9DSEFSVF9QTkdcIixcImFjdGlvblN1ZmZpeFwiOlwiRVhQT1JUX0NIQVJUX1BOR1wiLFwiaWNvblN1ZmZpeFwiOlwiZmlsZS1pbWFnZVwifV19OyJdLCJuYW1lcyI6WyJGaWxlU2F2ZXIiLCJ0b1BuZyIsInRvSnBlZyIsIndpdGhOYW1lIiwibG9nZ2VyIiwiX2dldF9fIiwiZGF0YVVyaVRvQmxvYiIsImRhdGFVcmkiLCJieXRlU3RyaW5nIiwiYXRvYiIsInNwbGl0IiwibWltZVN0cmluZyIsImFiIiwiQXJyYXlCdWZmZXIiLCJsZW5ndGgiLCJpYSIsIlVpbnQ4QXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsIkJsb2IiLCJ0eXBlIiwiaGFuZGxlQXN5bmNFeHBvcnRFcnJvcnMiLCJhc3luY0V4cG9ydGVyIiwiZXhwb3J0YWJsZUVsZW1lbnQiLCJlcnJvciIsImNhbGwiLCJQcm9taXNlIiwicmVqZWN0IiwiZXhwb3J0UG5nIiwiYmxvYiIsInNhdmVBcyIsImV4cG9ydEpwZWciLCJleHBvcnRDc3YiLCJnZXRFeHBvcnRDc3ZEYXRhIiwiZmlsZU5hbWUiLCJjc3ZGaWxlIiwiX0RlZmF1bHRFeHBvcnRWYWx1ZSIsImRlZmF1bHRWYWx1ZXMiLCJfZ2V0R2xvYmFsT2JqZWN0IiwiZ2xvYmFsIiwiZSIsIndpbmRvdyIsIl9SZXdpcmVNb2R1bGVJZF9fIiwiX2dldFJld2lyZU1vZHVsZUlkX18iLCJnbG9iYWxWYXJpYWJsZSIsIl9fJCRHTE9CQUxfUkVXSVJFX05FWFRfTU9EVUxFX0lEX18iLCJfZ2V0UmV3aXJlUmVnaXN0cnlfXyIsInRoZUdsb2JhbFZhcmlhYmxlIiwiX18kJEdMT0JBTF9SRVdJUkVfUkVHSVNUUllfXyIsIk9iamVjdCIsImNyZWF0ZSIsIl9nZXRSZXdpcmVFeHBvcnRzUmVnaXN0cnlfXyIsIl9fJCRHTE9CQUxfUkVXSVJFX0VYUE9SVFNfUkVHSVNUUllfXyIsIl9zeW5jX2ludGVybmFsX3N0YXRlX3dpdGhfZXhwb3J0c19fIiwiX2V4cG9ydHNfdG9fcmVzZXRfXyIsIk1hcCIsIl9yZWNvcmRfZXhwb3J0X3RvX3Jlc2V0X18iLCJ2YXJpYWJsZU5hbWUiLCJ2YWx1ZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiZXhwb3J0cyIsImhhcyIsInNldCIsIl9yZXN0b3JlX2V4cG9ydHNfXyIsImVudHJpZXMiLCJjbGVhciIsIl9tYXliZV91cGRhdGVfZXhwb3J0X18iLCJfZ2V0UmV3aXJlZERhdGFfXyIsIm1vZHVsZUlkIiwicmVnaXN0cnkiLCJyZXdpcmVEYXRhIiwiZXhwb3J0c1JlZ2lzdHJ5IiwicmVnaXN0ZXJSZXNldEFsbCIsInJlc3RvcmVGdW5jIiwidmFsdWVzIiwiSU5URU5USU9OQUxfVU5ERUZJTkVEIiwiX1Jld2lyZUFQSV9fIiwiYWRkUHJvcGVydHlUb0FQSU9iamVjdCIsIm5hbWUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJfc2V0X18iLCJfcmVzZXRfXyIsIl93aXRoX18iLCJ1bmRlZmluZWQiLCJfZ2V0X29yaWdpbmFsX18iLCJfZmlsdGVyV2lsZGNhcmRJbXBvcnRfXyIsIl9hc3NpZ25fXyIsIl9zZXRfb3JpZ2luYWxfXyIsIl92YWx1ZSIsIl91cGRhdGVfb3BlcmF0aW9uX18iLCJvcGVyYXRpb24iLCJwcmVmaXgiLCJvbGRWYWx1ZSIsIm5ld1ZhbHVlIiwia2V5cyIsImZvckVhY2giLCJnZXQiLCJkZWxldGUiLCJvYmplY3QiLCJyZXdpcmVkVmFyaWFibGVOYW1lcyIsInByZXZpb3VzVmFsdWVzIiwicmVzZXQiLCJjYWxsYmFjayIsInJlc3VsdCIsInRoZW4iLCJjYXRjaCIsIl90eXBlT2ZPcmlnaW5hbEV4cG9ydCIsImFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSIsImlzRXh0ZW5zaWJsZSIsIndpbGRjYXJkSW1wb3J0IiwidmFsaWRQcm9wZXJ0eU5hbWVzIiwiZmlsdGVyIiwicHJvcGVydHlOYW1lIiwicmVkdWNlIiwiZmlsdGVyZWRXaWxkY2FyZEltcG9ydCIsIl9fZ2V0X18iLCJfX0dldERlcGVuZGVuY3lfXyIsIl9fUmV3aXJlX18iLCJfX3NldF9fIiwiX19SZXNldERlcGVuZGVuY3lfXyIsIl9fUmV3aXJlQVBJX18iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@c3/ui/UiSdlChartExport.ts_uiComponentLibraryReact\n");

/***/ }),

/***/ "./node_modules/file-saver/FileSaver.js_uiComponentLibraryReact":
/*!**********************************************!*\
  !*** ./node_modules/file-saver/FileSaver.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if ( true && module.exports) {
  module.exports.saveAs = saveAs;
} else if (( true && __webpack_require__.amdD !== null) && (__webpack_require__.amdO !== null)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return saveAs;
  }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}


/***/ }),

/***/ "./node_modules/html-to-image/es/applyStyleWithOptions.js_uiComponentLibraryReact":
/*!****************************************************************!*\
  !*** ./node_modules/html-to-image/es/applyStyleWithOptions.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyStyleWithOptions: () => (/* binding */ applyStyleWithOptions)
/* harmony export */ });
function applyStyleWithOptions(node, options) {
    const { style } = node;
    if (options.backgroundColor) {
        style.backgroundColor = options.backgroundColor;
    }
    if (options.width) {
        style.width = `${options.width}px`;
    }
    if (options.height) {
        style.height = `${options.height}px`;
    }
    const manual = options.style;
    if (manual != null) {
        Object.keys(manual).forEach((key) => {
            style[key] = manual[key];
        });
    }
    return node;
}
//# sourceMappingURL=applyStyleWithOptions.js.map

/***/ }),

/***/ "./node_modules/html-to-image/es/cloneNode.js_uiComponentLibraryReact":
/*!****************************************************!*\
  !*** ./node_modules/html-to-image/es/cloneNode.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cloneNode: () => (/* binding */ cloneNode)
/* harmony export */ });
/* harmony import */ var _getBlobFromURL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBlobFromURL */ "./node_modules/html-to-image/es/getBlobFromURL.js_uiComponentLibraryReact");
/* harmony import */ var _clonePseudoElements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clonePseudoElements */ "./node_modules/html-to-image/es/clonePseudoElements.js_uiComponentLibraryReact");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/html-to-image/es/util.js_uiComponentLibraryReact");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



function cloneCanvasElement(node) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataURL = node.toDataURL();
        if (dataURL === 'data:,') {
            return Promise.resolve(node.cloneNode(false));
        }
        return (0,_util__WEBPACK_IMPORTED_MODULE_2__.createImage)(dataURL);
    });
}
function cloneVideoElement(node, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.resolve(node.poster)
            .then((url) => (0,_getBlobFromURL__WEBPACK_IMPORTED_MODULE_0__.getBlobFromURL)(url, options))
            .then((data) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.makeDataUrl)(data.blob, (0,_util__WEBPACK_IMPORTED_MODULE_2__.getMimeType)(node.poster) || data.contentType))
            .then((dataURL) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.createImage)(dataURL));
    });
}
function cloneSingleNode(node, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (node instanceof HTMLCanvasElement) {
            return cloneCanvasElement(node);
        }
        if (node instanceof HTMLVideoElement && node.poster) {
            return cloneVideoElement(node, options);
        }
        return Promise.resolve(node.cloneNode(false));
    });
}
const isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';
function cloneChildren(nativeNode, clonedNode, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const children = isSlotElement(nativeNode) && nativeNode.assignedNodes
            ? (0,_util__WEBPACK_IMPORTED_MODULE_2__.toArray)(nativeNode.assignedNodes())
            : (0,_util__WEBPACK_IMPORTED_MODULE_2__.toArray)(((_a = nativeNode.shadowRoot) !== null && _a !== void 0 ? _a : nativeNode).childNodes);
        if (children.length === 0 || nativeNode instanceof HTMLVideoElement) {
            return Promise.resolve(clonedNode);
        }
        return children
            .reduce((deferred, child) => deferred
            // eslint-disable-next-line no-use-before-define
            .then(() => cloneNode(child, options))
            .then((clonedChild) => {
            // eslint-disable-next-line promise/always-return
            if (clonedChild) {
                clonedNode.appendChild(clonedChild);
            }
        }), Promise.resolve())
            .then(() => clonedNode);
    });
}
function cloneCSSStyle(nativeNode, clonedNode) {
    const source = window.getComputedStyle(nativeNode);
    const target = clonedNode.style;
    if (!target) {
        return;
    }
    if (source.cssText) {
        target.cssText = source.cssText;
    }
    else {
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.toArray)(source).forEach((name) => {
            target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));
        });
    }
}
function cloneInputValue(nativeNode, clonedNode) {
    if (nativeNode instanceof HTMLTextAreaElement) {
        clonedNode.innerHTML = nativeNode.value;
    }
    if (nativeNode instanceof HTMLInputElement) {
        clonedNode.setAttribute('value', nativeNode.value);
    }
}
function decorate(nativeNode, clonedNode) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(clonedNode instanceof Element)) {
            return Promise.resolve(clonedNode);
        }
        return Promise.resolve()
            .then(() => cloneCSSStyle(nativeNode, clonedNode))
            .then(() => (0,_clonePseudoElements__WEBPACK_IMPORTED_MODULE_1__.clonePseudoElements)(nativeNode, clonedNode))
            .then(() => cloneInputValue(nativeNode, clonedNode))
            .then(() => clonedNode);
    });
}
function cloneNode(node, options, isRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isRoot && options.filter && !options.filter(node)) {
            return Promise.resolve(null);
        }
        return Promise.resolve(node)
            .then((clonedNode) => cloneSingleNode(clonedNode, options))
            .then((clonedNode) => cloneChildren(node, clonedNode, options))
            .then((clonedNode) => decorate(node, clonedNode));
    });
}
//# sourceMappingURL=cloneNode.js.map

/***/ }),

/***/ "./node_modules/html-to-image/es/clonePseudoElements.js_uiComponentLibraryReact":
/*!**************************************************************!*\
  !*** ./node_modules/html-to-image/es/clonePseudoElements.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clonePseudoElements: () => (/* binding */ clonePseudoElements)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/html-to-image/es/util.js_uiComponentLibraryReact");

function formatCSSText(style) {
    const content = style.getPropertyValue('content');
    return `${style.cssText} content: '${content.replace(/'|"/g, '')}';`;
}
function formatCSSProperties(style) {
    return (0,_util__WEBPACK_IMPORTED_MODULE_0__.toArray)(style)
        .map((name) => {
        const value = style.getPropertyValue(name);
        const priority = style.getPropertyPriority(name);
        return `${name}: ${value}${priority ? ' !important' : ''};`;
    })
        .join(' ');
}
function getPseudoElementStyle(className, pseudo, style) {
    const selector = `.${className}:${pseudo}`;
    const cssText = style.cssText
        ? formatCSSText(style)
        : formatCSSProperties(style);
    return document.createTextNode(`${selector}{${cssText}}`);
}
function clonePseudoElement(nativeNode, clonedNode, pseudo) {
    const style = window.getComputedStyle(nativeNode, pseudo);
    const content = style.getPropertyValue('content');
    if (content === '' || content === 'none') {
        return;
    }
    const className = (0,_util__WEBPACK_IMPORTED_MODULE_0__.uuid)();
    try {
        clonedNode.className = `${clonedNode.className} ${className}`;
    }
    catch (err) {
        return;
    }
    const styleElement = document.createElement('style');
    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));
    clonedNode.appendChild(styleElement);
}
function clonePseudoElements(nativeNode, clonedNode) {
    clonePseudoElement(nativeNode, clonedNode, ':before');
    clonePseudoElement(nativeNode, clonedNode, ':after');
}
//# sourceMappingURL=clonePseudoElements.js.map

/***/ }),

/***/ "./node_modules/html-to-image/es/embedImages.js_uiComponentLibraryReact":
/*!******************************************************!*\
  !*** ./node_modules/html-to-image/es/embedImages.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   embedImages: () => (/* binding */ embedImages)
/* harmony export */ });
/* harmony import */ var _getBlobFromURL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBlobFromURL */ "./node_modules/html-to-image/es/getBlobFromURL.js_uiComponentLibraryReact");
/* harmony import */ var _embedResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./embedResources */ "./node_modules/html-to-image/es/embedResources.js_uiComponentLibraryReact");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/html-to-image/es/util.js_uiComponentLibraryReact");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



function embedBackground(clonedNode, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const background = (_a = clonedNode.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue('background');
        if (!background) {
            return Promise.resolve(clonedNode);
        }
        return Promise.resolve(background)
            .then((cssString) => (0,_embedResources__WEBPACK_IMPORTED_MODULE_1__.embedResources)(cssString, null, options))
            .then((cssString) => {
            clonedNode.style.setProperty('background', cssString, clonedNode.style.getPropertyPriority('background'));
            return clonedNode;
        });
    });
}
function embedImageNode(clonedNode, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(clonedNode instanceof HTMLImageElement && !(0,_util__WEBPACK_IMPORTED_MODULE_2__.isDataUrl)(clonedNode.src)) &&
            !(clonedNode instanceof SVGImageElement &&
                !(0,_util__WEBPACK_IMPORTED_MODULE_2__.isDataUrl)(clonedNode.href.baseVal))) {
            return Promise.resolve(clonedNode);
        }
        const src = clonedNode instanceof HTMLImageElement
            ? clonedNode.src
            : clonedNode.href.baseVal;
        return Promise.resolve(src)
            .then((url) => (0,_getBlobFromURL__WEBPACK_IMPORTED_MODULE_0__.getBlobFromURL)(url, options))
            .then((data) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.makeDataUrl)(data.blob, (0,_util__WEBPACK_IMPORTED_MODULE_2__.getMimeType)(src) || data.contentType))
            .then((dataURL) => new Promise((resolve, reject) => {
            clonedNode.onload = resolve;
            clonedNode.onerror = reject;
            if (clonedNode instanceof HTMLImageElement) {
                clonedNode.srcset = '';
                clonedNode.src = dataURL;
            }
            else {
                clonedNode.href.baseVal = dataURL;
            }
        }))
            .then(() => clonedNode, () => clonedNode);
    });
}
function embedChildren(clonedNode, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const children = (0,_util__WEBPACK_IMPORTED_MODULE_2__.toArray)(clonedNode.childNodes);
        // eslint-disable-next-line no-use-before-define
        const deferreds = children.map((child) => embedImages(child, options));
        return Promise.all(deferreds).then(() => clonedNode);
    });
}
function embedImages(clonedNode, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(clonedNode instanceof Element)) {
            return Promise.resolve(clonedNode);
        }
        return Promise.resolve(clonedNode)
            .then((node) => embedBackground(node, options))
            .then((node) => embedImageNode(node, options))
            .then((node) => embedChildren(node, options));
    });
}
//# sourceMappingURL=embedImages.js.map

/***/ }),

/***/ "./node_modules/html-to-image/es/embedResources.js_uiComponentLibraryReact":
/*!*********************************************************!*\
  !*** ./node_modules/html-to-image/es/embedResources.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   embed: () => (/* binding */ embed),
/* harmony export */   embedResources: () => (/* binding */ embedResources),
/* harmony export */   parseURLs: () => (/* binding */ parseURLs),
/* harmony export */   shouldEmbed: () => (/* binding */ shouldEmbed),
/* harmony export */   toRegex: () => (/* binding */ toRegex)
/* harmony export */ });
/* harmony import */ var _getBlobFromURL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBlobFromURL */ "./node_modules/html-to-image/es/getBlobFromURL.js_uiComponentLibraryReact");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/html-to-image/es/util.js_uiComponentLibraryReact");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
const URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["'])([^"']+)\1\)/g;
const FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function toRegex(url) {
    // eslint-disable-next-line no-useless-escape
    const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1');
    return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, 'g');
}
function parseURLs(cssText) {
    const result = [];
    cssText.replace(URL_REGEX, (raw, quotation, url) => {
        result.push(url);
        return raw;
    });
    return result.filter((url) => !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isDataUrl)(url));
}
function embed(cssText, resourceURL, baseURL, options, get) {
    const resolvedURL = baseURL ? (0,_util__WEBPACK_IMPORTED_MODULE_1__.resolveUrl)(resourceURL, baseURL) : resourceURL;
    return Promise.resolve(resolvedURL)
        .then((url) => get ? get(url) : (0,_getBlobFromURL__WEBPACK_IMPORTED_MODULE_0__.getBlobFromURL)(url, options))
        .then((data) => {
        if (typeof data === 'string') {
            return (0,_util__WEBPACK_IMPORTED_MODULE_1__.makeDataUrl)(data, (0,_util__WEBPACK_IMPORTED_MODULE_1__.getMimeType)(resourceURL));
        }
        return (0,_util__WEBPACK_IMPORTED_MODULE_1__.makeDataUrl)(data.blob, (0,_util__WEBPACK_IMPORTED_MODULE_1__.getMimeType)(resourceURL) || data.contentType);
    })
        .then((dataURL) => cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`))
        .then((content) => content, () => resolvedURL);
}
function filterPreferredFontFormat(str, { preferredFontFormat }) {
    return !preferredFontFormat
        ? str
        : str.replace(FONT_SRC_REGEX, (match) => {
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
                if (!format) {
                    return '';
                }
                if (format === preferredFontFormat) {
                    return `src: ${src};`;
                }
            }
        });
}
function shouldEmbed(url) {
    return url.search(URL_REGEX) !== -1;
}
function embedResources(cssText, baseUrl, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!shouldEmbed(cssText)) {
            return Promise.resolve(cssText);
        }
        const filteredCSSText = filterPreferredFontFormat(cssText, options);
        return Promise.resolve(filteredCSSText)
            .then(parseURLs)
            .then((urls) => urls.reduce((deferred, url) => 
        // eslint-disable-next-line promise/no-nesting
        deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText)));
    });
}
//# sourceMappingURL=embedResources.js.map

/***/ }),

/***/ "./node_modules/html-to-image/es/embedWebFonts.js_uiComponentLibraryReact":
/*!********************************************************!*\
  !*** ./node_modules/html-to-image/es/embedWebFonts.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   embedWebFonts: () => (/* binding */ embedWebFonts),
/* harmony export */   getWebFontCSS: () => (/* binding */ getWebFontCSS)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/html-to-image/es/util.js_uiComponentLibraryReact");
/* harmony import */ var _embedResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./embedResources */ "./node_modules/html-to-image/es/embedResources.js_uiComponentLibraryReact");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const cssFetchCache = {};
function fetchCSS(url) {
    const cache = cssFetchCache[url];
    if (cache != null) {
        return cache;
    }
    const deferred = window.fetch(url).then((res) => ({
        url,
        cssText: res.text(),
    }));
    cssFetchCache[url] = deferred;
    return deferred;
}
function embedFonts(meta) {
    return __awaiter(this, void 0, void 0, function* () {
        return meta.cssText.then((raw) => {
            let cssText = raw;
            const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
            const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
            const loadFonts = fontLocs.map((location) => {
                let url = location.replace(regexUrl, '$1');
                if (!url.startsWith('https://')) {
                    url = new URL(url, meta.url).href;
                }
                // eslint-disable-next-line promise/no-nesting
                return window
                    .fetch(url)
                    .then((res) => res.blob())
                    .then((blob) => new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        // Side Effect
                        cssText = cssText.replace(location, `url(${reader.result})`);
                        resolve([location, reader.result]);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                }));
            });
            // eslint-disable-next-line promise/no-nesting
            return Promise.all(loadFonts).then(() => cssText);
        });
    });
}
function parseCSS(source) {
    if (source == null) {
        return [];
    }
    const result = [];
    const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
    // strip out comments
    let cssText = source.replace(commentsRegex, '');
    const keyframesRegex = new RegExp('((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})', 'gi');
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const matches = keyframesRegex.exec(cssText);
        if (matches === null) {
            break;
        }
        result.push(matches[0]);
    }
    cssText = cssText.replace(keyframesRegex, '');
    const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
    // to match css & media queries together
    const combinedCSSRegex = '((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]' +
        '*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})';
    // unified regex
    const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');
    // eslint-disable-next-line no-constant-condition
    while (true) {
        let matches = importRegex.exec(cssText);
        if (matches === null) {
            matches = unifiedRegex.exec(cssText);
            if (matches === null) {
                break;
            }
            else {
                importRegex.lastIndex = unifiedRegex.lastIndex;
            }
        }
        else {
            unifiedRegex.lastIndex = importRegex.lastIndex;
        }
        result.push(matches[0]);
    }
    return result;
}
function getCSSRules(styleSheets) {
    return __awaiter(this, void 0, void 0, function* () {
        const ret = [];
        const deferreds = [];
        // First loop inlines imports
        styleSheets.forEach((sheet) => {
            if ('cssRules' in sheet) {
                try {
                    (0,_util__WEBPACK_IMPORTED_MODULE_0__.toArray)(sheet.cssRules).forEach((item, index) => {
                        if (item.type === CSSRule.IMPORT_RULE) {
                            let importIndex = index + 1;
                            const url = item.href;
                            const deferred = fetchCSS(url)
                                .then((metadata) => (metadata ? embedFonts(metadata) : ''))
                                .then((cssText) => parseCSS(cssText).forEach((rule) => {
                                try {
                                    sheet.insertRule(rule, rule.startsWith('@import')
                                        ? (importIndex += 1)
                                        : sheet.cssRules.length);
                                }
                                catch (error) {
                                    console.error('Error inserting rule from remote css', {
                                        rule,
                                        error,
                                    });
                                }
                            }))
                                .catch((e) => {
                                console.error('Error loading remote css', e.toString());
                            });
                            deferreds.push(deferred);
                        }
                    });
                }
                catch (e) {
                    const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];
                    if (sheet.href != null) {
                        deferreds.push(fetchCSS(sheet.href)
                            .then((metadata) => (metadata ? embedFonts(metadata) : ''))
                            .then((cssText) => parseCSS(cssText).forEach((rule) => {
                            inline.insertRule(rule, sheet.cssRules.length);
                        }))
                            .catch((err) => {
                            console.error('Error loading remote stylesheet', err.toString());
                        }));
                    }
                    console.error('Error inlining remote css file', e.toString());
                }
            }
        });
        return Promise.all(deferreds).then(() => {
            // Second loop parses rules
            styleSheets.forEach((sheet) => {
                if ('cssRules' in sheet) {
                    try {
                        (0,_util__WEBPACK_IMPORTED_MODULE_0__.toArray)(sheet.cssRules).forEach((item) => {
                            ret.push(item);
                        });
                    }
                    catch (e) {
                        console.error(`Error while reading CSS rules from ${sheet.href}`, e.toString());
                    }
                }
            });
            return ret;
        });
    });
}
function getWebFontRules(cssRules) {
    return cssRules
        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)
        .filter((rule) => (0,_embedResources__WEBPACK_IMPORTED_MODULE_1__.shouldEmbed)(rule.style.getPropertyValue('src')));
}
function parseWebFontRules(node) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (node.ownerDocument == null) {
                reject(new Error('Provided element is not within a Document'));
            }
            resolve((0,_util__WEBPACK_IMPORTED_MODULE_0__.toArray)(node.ownerDocument.styleSheets));
        })
            .then((styleSheets) => getCSSRules(styleSheets))
            .then(getWebFontRules);
    });
}
function getWebFontCSS(node, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return parseWebFontRules(node)
            .then((rules) => Promise.all(rules.map((rule) => {
            const baseUrl = rule.parentStyleSheet
                ? rule.parentStyleSheet.href
                : null;
            return (0,_embedResources__WEBPACK_IMPORTED_MODULE_1__.embedResources)(rule.cssText, baseUrl, options);
        })))
            .then((cssTexts) => cssTexts.join('\n'));
    });
}
function embedWebFonts(clonedNode, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return (options.fontEmbedCSS != null
            ? Promise.resolve(options.fontEmbedCSS)
            : getWebFontCSS(clonedNode, options)).then((cssText) => {
            const styleNode = document.createElement('style');
            const sytleContent = document.createTextNode(cssText);
            styleNode.appendChild(sytleContent);
            if (clonedNode.firstChild) {
                clonedNode.insertBefore(styleNode, clonedNode.firstChild);
            }
            else {
                clonedNode.appendChild(styleNode);
            }
            return clonedNode;
        });
    });
}
//# sourceMappingURL=embedWebFonts.js.map

/***/ }),

/***/ "./node_modules/html-to-image/es/getBlobFromURL.js_uiComponentLibraryReact":
/*!*********************************************************!*\
  !*** ./node_modules/html-to-image/es/getBlobFromURL.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBlobFromURL: () => (/* binding */ getBlobFromURL)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/html-to-image/es/util.js_uiComponentLibraryReact");

const cache = {};
function getCacheKey(url) {
    let key = url.replace(/\?.*/, '');
    // font resourse
    if (/ttf|otf|eot|woff2?/i.test(key)) {
        key = key.replace(/.*\//, '');
    }
    return key;
}
function getBlobFromURL(url, options) {
    const cacheKey = getCacheKey(url);
    if (cache[cacheKey] != null) {
        return cache[cacheKey];
    }
    // cache bypass so we dont have CORS issues with cached images
    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
    if (options.cacheBust) {
        // eslint-disable-next-line no-param-reassign
        url += (/\?/.test(url) ? '&' : '?') + new Date().getTime();
    }
    const failed = (reason) => {
        let placeholder = '';
        if (options.imagePlaceholder) {
            const parts = options.imagePlaceholder.split(/,/);
            if (parts && parts[1]) {
                placeholder = parts[1];
            }
        }
        let msg = `Failed to fetch resource: ${url}`;
        if (reason) {
            msg = typeof reason === 'string' ? reason : reason.message;
        }
        if (msg) {
            console.error(msg);
        }
        return {
            blob: placeholder,
            contentType: '',
        };
    };
    const deferred = window
        .fetch(url)
        .then((res) => 
    // eslint-disable-next-line promise/no-nesting
    res.blob().then((blob) => ({
        blob,
        contentType: res.headers.get('Content-Type') || '',
    })))
        .then(({ blob, contentType }) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve({
            contentType,
            blob: reader.result,
        });
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    }))
        .then(({ blob, contentType }) => ({
        contentType,
        blob: (0,_util__WEBPACK_IMPORTED_MODULE_0__.parseDataUrlContent)(blob),
    }))
        // on failed
        .catch(failed);
    // cache result
    cache[cacheKey] = deferred;
    return deferred;
}
//# sourceMappingURL=getBlobFromURL.js.map

/***/ }),

/***/ "./node_modules/html-to-image/es/index.js_uiComponentLibraryReact":
/*!************************************************!*\
  !*** ./node_modules/html-to-image/es/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFontEmbedCSS: () => (/* binding */ getFontEmbedCSS),
/* harmony export */   toBlob: () => (/* binding */ toBlob),
/* harmony export */   toCanvas: () => (/* binding */ toCanvas),
/* harmony export */   toJpeg: () => (/* binding */ toJpeg),
/* harmony export */   toPixelData: () => (/* binding */ toPixelData),
/* harmony export */   toPng: () => (/* binding */ toPng),
/* harmony export */   toSvg: () => (/* binding */ toSvg)
/* harmony export */ });
/* harmony import */ var _cloneNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cloneNode */ "./node_modules/html-to-image/es/cloneNode.js_uiComponentLibraryReact");
/* harmony import */ var _embedImages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./embedImages */ "./node_modules/html-to-image/es/embedImages.js_uiComponentLibraryReact");
/* harmony import */ var _applyStyleWithOptions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./applyStyleWithOptions */ "./node_modules/html-to-image/es/applyStyleWithOptions.js_uiComponentLibraryReact");
/* harmony import */ var _embedWebFonts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./embedWebFonts */ "./node_modules/html-to-image/es/embedWebFonts.js_uiComponentLibraryReact");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./node_modules/html-to-image/es/util.js_uiComponentLibraryReact");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





function getImageSize(node, options = {}) {
    const width = options.width || (0,_util__WEBPACK_IMPORTED_MODULE_4__.getNodeWidth)(node);
    const height = options.height || (0,_util__WEBPACK_IMPORTED_MODULE_4__.getNodeHeight)(node);
    return { width, height };
}
function toSvg(node, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { width, height } = getImageSize(node, options);
        return Promise.resolve(node)
            .then((nativeNode) => (0,_cloneNode__WEBPACK_IMPORTED_MODULE_0__.cloneNode)(nativeNode, options, true))
            .then((clonedNode) => (0,_embedWebFonts__WEBPACK_IMPORTED_MODULE_3__.embedWebFonts)(clonedNode, options))
            .then((clonedNode) => (0,_embedImages__WEBPACK_IMPORTED_MODULE_1__.embedImages)(clonedNode, options))
            .then((clonedNode) => (0,_applyStyleWithOptions__WEBPACK_IMPORTED_MODULE_2__.applyStyleWithOptions)(clonedNode, options))
            .then((clonedNode) => (0,_util__WEBPACK_IMPORTED_MODULE_4__.nodeToDataURL)(clonedNode, width, height));
    });
}
const dimensionCanvasLimit = 16384; // as per https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size
function checkCanvasDimensions(canvas) {
    if (canvas.width > dimensionCanvasLimit ||
        canvas.height > dimensionCanvasLimit) {
        if (canvas.width > dimensionCanvasLimit &&
            canvas.height > dimensionCanvasLimit) {
            if (canvas.width > canvas.height) {
                canvas.height *= dimensionCanvasLimit / canvas.width;
                canvas.width = dimensionCanvasLimit;
            }
            else {
                canvas.width *= dimensionCanvasLimit / canvas.height;
                canvas.height = dimensionCanvasLimit;
            }
        }
        else if (canvas.width > dimensionCanvasLimit) {
            canvas.height *= dimensionCanvasLimit / canvas.width;
            canvas.width = dimensionCanvasLimit;
        }
        else {
            canvas.width *= dimensionCanvasLimit / canvas.height;
            canvas.height = dimensionCanvasLimit;
        }
    }
}
function toCanvas(node, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return toSvg(node, options)
            .then(_util__WEBPACK_IMPORTED_MODULE_4__.createImage)
            .then((img) => {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const ratio = options.pixelRatio || (0,_util__WEBPACK_IMPORTED_MODULE_4__.getPixelRatio)();
            const { width, height } = getImageSize(node, options);
            const canvasWidth = options.canvasWidth || width;
            const canvasHeight = options.canvasHeight || height;
            canvas.width = canvasWidth * ratio;
            canvas.height = canvasHeight * ratio;
            if (!options.skipAutoScale) {
                checkCanvasDimensions(canvas);
            }
            canvas.style.width = `${canvasWidth}`;
            canvas.style.height = `${canvasHeight}`;
            if (options.backgroundColor) {
                context.fillStyle = options.backgroundColor;
                context.fillRect(0, 0, canvas.width, canvas.height);
            }
            context.drawImage(img, 0, 0, canvas.width, canvas.height);
            return canvas;
        });
    });
}
function toPixelData(node, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { width, height } = getImageSize(node, options);
        return toCanvas(node, options).then((canvas) => {
            const ctx = canvas.getContext('2d');
            return ctx.getImageData(0, 0, width, height).data;
        });
    });
}
function toPng(node, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return toCanvas(node, options).then((canvas) => canvas.toDataURL());
    });
}
function toJpeg(node, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return toCanvas(node, options).then((canvas) => canvas.toDataURL('image/jpeg', options.quality || 1));
    });
}
function toBlob(node, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return toCanvas(node, options).then(_util__WEBPACK_IMPORTED_MODULE_4__.canvasToBlob);
    });
}
function getFontEmbedCSS(node, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0,_embedWebFonts__WEBPACK_IMPORTED_MODULE_3__.getWebFontCSS)(node, options);
    });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/html-to-image/es/util.js_uiComponentLibraryReact":
/*!***********************************************!*\
  !*** ./node_modules/html-to-image/es/util.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canvasToBlob: () => (/* binding */ canvasToBlob),
/* harmony export */   createImage: () => (/* binding */ createImage),
/* harmony export */   delay: () => (/* binding */ delay),
/* harmony export */   getExtension: () => (/* binding */ getExtension),
/* harmony export */   getMimeType: () => (/* binding */ getMimeType),
/* harmony export */   getNodeHeight: () => (/* binding */ getNodeHeight),
/* harmony export */   getNodeWidth: () => (/* binding */ getNodeWidth),
/* harmony export */   getPixelRatio: () => (/* binding */ getPixelRatio),
/* harmony export */   isDataUrl: () => (/* binding */ isDataUrl),
/* harmony export */   makeDataUrl: () => (/* binding */ makeDataUrl),
/* harmony export */   nodeToDataURL: () => (/* binding */ nodeToDataURL),
/* harmony export */   parseDataUrlContent: () => (/* binding */ parseDataUrlContent),
/* harmony export */   resolveUrl: () => (/* binding */ resolveUrl),
/* harmony export */   svgToDataURL: () => (/* binding */ svgToDataURL),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   uuid: () => (/* binding */ uuid)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const WOFF = 'application/font-woff';
const JPEG = 'image/jpeg';
const mimes = {
    woff: WOFF,
    woff2: WOFF,
    ttf: 'application/font-truetype',
    eot: 'application/vnd.ms-fontobject',
    png: 'image/png',
    jpg: JPEG,
    jpeg: JPEG,
    gif: 'image/gif',
    tiff: 'image/tiff',
    svg: 'image/svg+xml',
};
function getExtension(url) {
    const match = /\.([^./]*?)$/g.exec(url);
    return match ? match[1] : '';
}
function getMimeType(url) {
    const extension = getExtension(url).toLowerCase();
    return mimes[extension] || '';
}
function resolveUrl(url, baseUrl) {
    // url is absolute already
    if (url.match(/^[a-z]+:\/\//i)) {
        return url;
    }
    // url is absolute already, without protocol
    if (url.match(/^\/\//)) {
        return window.location.protocol + url;
    }
    // dataURI, mailto:, tel:, etc.
    if (url.match(/^[a-z]+:/i)) {
        return url;
    }
    const doc = document.implementation.createHTMLDocument();
    const base = doc.createElement('base');
    const a = doc.createElement('a');
    doc.head.appendChild(base);
    doc.body.appendChild(a);
    if (baseUrl) {
        base.href = baseUrl;
    }
    a.href = url;
    return a.href;
}
function isDataUrl(url) {
    return url.search(/^(data:)/) !== -1;
}
function makeDataUrl(content, mimeType) {
    return `data:${mimeType};base64,${content}`;
}
function parseDataUrlContent(dataURL) {
    return dataURL.split(/,/)[1];
}
const uuid = (function uuid() {
    // generate uuid for className of pseudo elements.
    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.
    let counter = 0;
    // ref: http://stackoverflow.com/a/6248722/2519373
    const random = () => 
    // eslint-disable-next-line no-bitwise
    `0000${((Math.random() * Math.pow(36, 4)) << 0).toString(36)}`.slice(-4);
    return () => {
        counter += 1;
        return `u${random()}${counter}`;
    };
})();
const delay = (ms) => (args) => new Promise((resolve) => setTimeout(() => resolve(args), ms));
function toArray(arrayLike) {
    const arr = [];
    for (let i = 0, l = arrayLike.length; i < l; i += 1) {
        arr.push(arrayLike[i]);
    }
    return arr;
}
function px(node, styleProperty) {
    const val = window.getComputedStyle(node).getPropertyValue(styleProperty);
    return parseFloat(val.replace('px', ''));
}
function getNodeWidth(node) {
    const leftBorder = px(node, 'border-left-width');
    const rightBorder = px(node, 'border-right-width');
    return node.clientWidth + leftBorder + rightBorder;
}
function getNodeHeight(node) {
    const topBorder = px(node, 'border-top-width');
    const bottomBorder = px(node, 'border-bottom-width');
    return node.clientHeight + topBorder + bottomBorder;
}
function getPixelRatio() {
    let ratio;
    let FINAL_PROCESS;
    try {
        FINAL_PROCESS = process;
    }
    catch (e) {
        // pass
    }
    const val = FINAL_PROCESS && FINAL_PROCESS.env
        ? FINAL_PROCESS.env.devicePixelRatio
        : null;
    if (val) {
        ratio = parseInt(val, 10);
        if (Number.isNaN(ratio)) {
            ratio = 1;
        }
    }
    return ratio || window.devicePixelRatio || 1;
}
function canvasToBlob(canvas) {
    if (canvas.toBlob) {
        return new Promise((resolve) => canvas.toBlob(resolve));
    }
    return new Promise((resolve) => {
        const binaryString = window.atob(canvas.toDataURL().split(',')[1]);
        const len = binaryString.length;
        const binaryArray = new Uint8Array(len);
        for (let i = 0; i < len; i += 1) {
            binaryArray[i] = binaryString.charCodeAt(i);
        }
        resolve(new Blob([binaryArray], { type: 'image/png' }));
    });
}
function createImage(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.crossOrigin = 'anonymous';
        img.decoding = 'sync';
        img.src = url;
    });
}
function svgToDataURL(svg) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.resolve()
            .then(() => new XMLSerializer().serializeToString(svg))
            .then(encodeURIComponent)
            .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
    });
}
function nodeToDataURL(node, width, height) {
    return __awaiter(this, void 0, void 0, function* () {
        const xmlns = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(xmlns, 'svg');
        const foreignObject = document.createElementNS(xmlns, 'foreignObject');
        svg.setAttribute('width', `${width}`);
        svg.setAttribute('height', `${height}`);
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        foreignObject.setAttribute('width', '100%');
        foreignObject.setAttribute('height', '100%');
        foreignObject.setAttribute('x', '0');
        foreignObject.setAttribute('y', '0');
        foreignObject.setAttribute('externalResourcesRequired', 'true');
        svg.appendChild(foreignObject);
        foreignObject.appendChild(node);
        return svgToDataURL(svg);
    });
}
//# sourceMappingURL=util.js.map

/***/ })

}]);